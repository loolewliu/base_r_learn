---
title: "基础学习"
author: 
  - "liulifeng@163.com" #作者信息
  - "`r Sys.Date()`" #自动获取当前日期
output: 
  prettydoc::html_pretty:
    #可以从齿轮-Output Options中设置
    css: sspai.css #css模板，定义整个文档的格式，比如一级标题的字体字号等
    highlight: tango #代码高亮风格
    # number_sections: yes #是否自动按节编号
    # theme: cayman # 1
    # theme: tactile #2
    # theme: architect #3
    theme: leonids #4
    # theme: hpstr #5
    toc: yes #是否自动生成目录
---

# 0. base-r

## 0.1 


# 1.数据结构
* 数据类型
    * 数值型：数值可以用于直接结算，加减乘除
    * 字符串型：可以进行连接、转换、提取等
    * 逻辑型：或真或假
    * 日期型等 
* 数据结构
    * 向量
    * 矩阵
    * 数据库
    * 多维数组
    * 列表
    * 对象
    

## 1.1 数值型向量

**向量**是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。<br>

用c()函数把多个元素或向量组合成一个向量。如

```{r}
 # 返回x的长度, 
length(c(1,2,3))
```

```{r}
# 初始化一个指定元素个数而元素都等于零的数值型向量
numeric(3)
```

### 1.1.1 标量与标量之间运算

```{r}
# + - * / ^ 加减乘除乘方
2+1
2-1
3*3
3/2
2^3

# %/% 整除 %%求余
5 %/% 3
5 %% 3
```


```{r}
# 圆括号()改变运算的先后次序
1.5 + 2.3 - (0.6 + 0.4)*1.5 - 1.5/0.5 + 2^3
```

### 1.1.2 向量与标量之间运算


向量与标量的运算为每个元素与标量的运算

```{r}
x <- c(1,20)
x+2
x-2
x*2
x/2
x^2
x%/%2
x%%2
```
 四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。 如

```{r}
c(1,NA,3) * 2
```

### 1.1.3 等长向量运算

对应元素两两运算
```{r}
x <- c(1,10)
y <- c(2,9)
x + y
x - y
x / y
```

### 1.1.4 不等长向量运算

* 长度为倍数关系，规则是每次从头重复利用短的一个。 如
```{r}
x <- c(1,3)
y <- c(2,4,6,8)

x + y
x - y
```

* 两个向量的长度不是倍数关系，会给出警告信息。如
```{r}
c(1,2) + c(1,2,3)
```

### 1.1.5 向量化函数 `help.start()`

查看这些基础的数学函数的列表，运行命令`help.start()`， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有
```{r}
# 舍入 ceiling, floor, round, signif, trunc, zapsmall

ceiling(c(1.5, -1.2))     # 向上取整
floor(c(1.5, -1.2))       # 向下取整
round(c(pi), digits = 2)  # 四舍五入保留小数点2位
signif(c(pi), digits = 2) # 四舍五入保留2位有效数字
trunc(pi * 10^(-2:1))     # 保留整数部分
```

```{r}
# 符号函数 sign  返回值：1 代表正数，-1 代表负数
x <- c(1, 5, 0, -10, 100, -20, 10, -69)
cat("Sign of elements of vector x:", sign(x), "\n")
```
```{r}
# 绝对值函数
abs(c(pi, -pi))
```
```{r} 
# sqrt 平方根  x^(1/3) 立方根
x <- seq(1,10,2)
sqrt(x)
x^(1/2)
```

```{r}
# 对数与指数函数 log, exp, log10, log2
log(4,base = 2) # 以2为底4的对数
log2(4)         # 以2为底4的对数
log10(100)      # 以10为底100的对数
exp(1)          # e的多少次方
```

```{r}
# 三角函数， 反三角函数
sin(pi/6) 
cos(pi/6)
tan(pi/6)
asin(0.5)
acos(0.5)
atan(1)
#atan2(1)

```
### 1.1.6 排序函数

* `sort(x)`返回排序结果，默认是升序。 
* `rev(x)`返回把各元素排列次序反转后的结果。
* `order(x)`返回排序(升序)用的下标。如

```{r}
x <- c(11,44,22)
sort(x)                     # 默认升序(decreasing = FALSE)，
sort(x, decreasing = TRUE)  # 设置位降序
rev(sort(x))                # 等价与  sort(x, decreasing = TRUE)  # 设置位降序
order(x)                    # 结果中的2是x的最大元素44所在的位置下标
x[order(x)]                 # 等价 sort(x) 
```
### 1.1.7 统计函数


```{r}
# 简单统计函数 max() min() range() sum() mean() sd() var()  median() quantile()
x <- c(1:10)
max(x)      # 最大值
min(x)      # 最小值
range(x)    # 返回2个值，分别是最小值和最大值
sum(x)      # 求和
mean(x)     # 均值
var(x)      # 方差
sqrt(var(x))# 标准差
sd(x)       # 标准差
median(x)   # 中位数
quantile(x) # 四分卫位数
quantile(x,c(0.4, 0.8)) # 指定百分比的分位数
prod(x)     # 连乘积
```

cumsum和cumprod计算累加和累乘积。

```{r}
cumsum(1:5)   # 累加和
cumprod(1:5)  # 累乘积 
```
### 1.1.8 生成序列函数
`seq函数`是冒号运算符的推广。 比如，`seq(5)`等同于1:5。 `seq(2,5)`等同于2:5。

```{r}
# seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),length.out = NULL, along.with = NULL, ...)

seq(from=1, to=10, by=2) # 从1到10 间隔为2
seq(1,10,2) # 简写形式
seq(from=1, to=10, length.out=3) # [1,10]之间取3个数，等间距
```

```{r}
# rep 重复元素
rep(c(1,2), time=2) # 向量重复出现2次
rep(c(1,2), each=2, time=2) # 向量的每个元素重复2遍， 再重复的元素在重复2遍

```

小问题： 1:5和seq(5)的结果是整型（integer）的， c(1,3,5)和seq(1, 5, by=2)的结果是浮点型（double）的。


## 1.2 逻辑型向量及运算

### 1.2.1 逻辑型向量与比较运算符


逻辑型是R的基本数据类型之一，只有两个值**TRUE**和**FALSE**, 缺失时为**NA**。逻辑值一般在比较中产生。向量比较的结果为逻辑向量。

```{r}
sele <- (log10(15) < 2); print(sele)
c(1,3,4) > 3
c(1:4) > c(4:1)
```

> 从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。


* 与NA比较产生NA，如
```{r}
c(1, NA, 3) > 2    # [1] FALSE    NA  TRUE
NA == NA           # [1] NA
```

* 为了判断向量每个元素是否NA， 用is.na()函数，如
```{r}
is.na(c(1, NA, 3))    # [1] FALSE  TRUE FALSE
```

* 用`is.finite()`判断向量每个元素是否**Inf**值

**比较运算符**
<   <=  >  >=  ==  !=  %in%   
分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意**等于比较**用了两个等号

* %in%是特殊的比较， x %in% y的运算把向量y看成集合，运算结果是一个逻辑型向量，x向量中的每个值是否属于y向量。如
```{r}
c(1, 3) %in% c(2,3,4)       # [1] FALSE  TRUE
c(1,3) %in% c(NA, 3, 4)     # [1] FALSE  TRUE
c(NA,3) %in% c(NA, 3, 4)    # [1] TRUE TRUE
```

函数**match(x, y)**起到和x %in% y运算类似的作用， 但是其返回结果不是找到与否， 而是对x的每个元素， 找到其在y中首次出现的下标，找不到时取缺失值，如
```{r}
match(c(1, 3), c(2,3,4,3))  ## [1] NA  2
```

### 1.2.2 逻辑运算

* 逻辑运算符为`&`, `|`和`!`, 分别表示“同时成立”、“两者至少其一成立”、“条件的反面”。运算的先后次序可以用圆括号()指定.

> age<=3 & sex=='女'表示女婴,;
> age<=3 | sex=='女'表示婴儿或妇女;
> !(age<=3 | sex=='女')表示既非婴儿也非妇女

* 在右运算符是缺失值时， 如果左运算符能够确定结果真假， 可以得到非缺失的结果。 例如，`TRUE | NA`为TRUE,` FALSE & NA`为FALSE。 不能确定结果时返回`NA`， 比如， `TRUE & NA`为NA, `FALSE | NA`为NA。

* 标量之间的逻辑比较，`&&`和`||`分别为短路的标量逻辑与和短路的标量逻辑或
`if(TRUE || sqrt(-1)>0) next` ,其中的`sqrt(-1)`部分不会执行。 其中条件的结果为`TRUE`, 第二部分没有参加计算， 否则第二部分的计算会发生函数自变量范围错误。

#### 1.1.2.3 逻辑运算函数

`if`结构、`while`结构都需要**逻辑标量**而且不能是缺失值。 这时，应该对缺失值结果单独考虑。

若`cond`是逻辑向量
* 用`all(cond)`测试`cond`的所有元素为真； 
* 用`any(cond)`测试`cond`至少一个元素为真。
`cond`中允许有缺失值，结果可能为缺失值。 如

```{r}
c(1, NA, 3) > 2         ## [1] FALSE    NA  TRUE
all(c(1, NA, 3) > 2)    ## [1] FALSE
any(c(1, NA, 3) > 2)    ## [1] TRUE
all(NA)                 ## [1] NA
any(NA)                 ## [1] NA
```
函数`which()`返回真值对应的所有下标，如
```{r}
which(c(T, F, T, NA))
which(c(2:5) > 4)
x <- c(2, 3, 5, 7, 11, 13);x <- x[-which(x == 5)]
```
函数`identical(x,y)`比较两个R对象`x`与`y`的内容是否完全相同， 结果只会取标量`TRUE`与`FALSE`两种。 如
```{r}
identical(c(1,2,3), c(1,2,NA))
identical(c(1L,2L,3L), c(1,2,3))   # 结果假值是因为前一向量是整数型， 后一向量是实数型。
```
函数`duplicated()`返回每个元素是否为重复值的结果，用函数`unique()`可以返回去掉重复值的结果。如：

```{r}
duplicated(c(1,2,1,3,NA,4,NA))
unique(c(1,2,1,3,NA,4,NA))
```

## 1.3 字符型数据及处理

### 1.3.1 字符型向量
元素为字符串的向。字符串在程序中写成用两个双撇号包围或者用两个单撇号包围的内容。 如
```{r}
s <- c('a', "b", NA, FALSE, '', '小明') ; cat(s)
```
> 注意**空字符串**并不能自动认为是缺失值， 字符型的缺失值仍用NA表示。

### 1.3.2 转义字符和原始字符串

* 用**反斜杠**在前面标明， 称为“转义”，如：
```{r}
cat("\"\n")
```

* 当需要转义的内容较多时， 可以使用原始字符串(raw string)， 方法是用`r"(...)"`的格式， 其中`...`是实际内容。如：

```{r}
cat(r"(F:\Code\R\00.base\n)")    # 注意其中\n也被当作普通字符解释了， 不再当作换行符。
```

原始字符串如果内容中包含了圆括号， 可以将边界的圆括号改为方括号[]或者大括号{}。 如果这样也不能避免歧义， 可以在开始和结尾加上相同个数的减号， 格式为`r"--(...)--"`， 其中...为实际内容， 减号个数可以根据需要增加。
```{r}
cat(r"--{my_str()}--")  # 等价于 cat(r"(my_str())")

```

### 1.3.3 字符数统计

* `nchar()` 字符串向量中每个元素的字符个数
* `length()` 向量中元素的个数，即向量的长度
```{r}
nchar(R.version.string)      # R version 4.3.1 (2023-06-16 ucrt)
nchar(NA)                    # NA
nchar(pi)                    # 16
```

> `R.version`返回一个列表

```{r}
R.version
R.version$language
```
### 1.3.4 转换大小写

* `toupper()`函数把字符型向量内容转为大写
* `tolower()`函数转为小写。

```{r}
toupper(c('appLE', 'Red'))
tolower(c('appLE', 'Red'))

x <- 'JAn'; toupper(x) == "JAN"
```

### 1.3.5 字符串的连接

* `paste()`用来连接两个字符型向量， 元素一一对应连接， 默认用空格连接(`seq = " "`)。
    * `sep=`指定分隔符。
    * `collapse=`参数可以把字符型向量的各个元素连接成一个单一的字符串。
```{r}
paste(c('ab', 'cd'), c('ef', 'gh'))     # 等价于 c("ab ef", "cd gh")
paste('x', 1:3, sep="")                 # 等价于c("x1" "x2" "x3")
paste('x', 1:3, collapse = "", sep = "")# 等价于c("x1x2x3")
```
* `paste0()` 相当于 `sep` 设为空，没有连接符.
```{r}
paste0("A", "B")
paste0(c("A", "B", "C"), 1:3)
paste0(c("A", "B", "C"), 1:3, collapse = ";")
```
    
### 1.3.6 字符串拆分
`strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)` <br/>

* `x `是被拆分的字符串向量，其每个元素都会被拆分，
* `split` 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。
* `fixed = FALSE` 表示正则表达式匹配，而 `fixed = TRUE` 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。
* 使用 `perl = TRUE` 使用`perl`语言正则语法，可以提高运算速度
* `useBytes` 设置是否按照逐个字节地进行匹配，默认不按照字节逐个匹配


```{r}
x <- c(as = "abcdef", qu = "merry", "yuiop[", "b", "plot")
strsplit(x, 'e')   # 返回列表的字符串
strsplit("a.b.c", ".", fixed = TRUE)    # 按点号拆分, 等价于 strsplit("a.b.c", "\\.") 等价于 strsplit("a.b.c", "\\.", perl = TRUE)
```

* 一个将字符串逆序的函数

```{r}
str_rev <- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
str_rev(c("abc", "Statistics"))
```

* `sapply()`函数配合`strsplit()`函数进行截取字符串
  * 函数sapply()可以提取列表中每个成分的第n个元素，并将其放入向量中进行存储，
  * "["是一个可以提取某个对象的一部分的函数。
```{r}
y <- c("100-D","100-A","110-c","110-A")
sapply(strsplit(y,"-"), '[', 1)   # 第一部分
sapply(strsplit(y,"-"), '[', 2)   # 第二部分
``` 

### 1.3.7 正则表达式

R 内置的三种匹配模式 <br>
1. `fixed = TRUE` : 字面意思匹配,不使用正则表达式 <br>
2. `perl = TRUE`  : 使用 Perl 正则表达式 <br>
3. `fixed = FALSE, perl = FALSE` : 使用 POSIX 1003.2 extended 正则表达式 (默认设置). <br>

正则表达式 (regular expression，简称 regexp)
R 内支持正则表达式的函数有 `grep`、`grepl`、`sub`、`gsub`、`regexpr`、`gregexpr` 、 `regexec` 和 `strsplit`。<br>
函数 `apropos`，`browseEnv`，`help.search`，`list.files` 和 `ls` 是通过函数 `grep` 来使用正则表达式的，它们全都使用 extended regular expressions
* 反斜杠 `\` 本身是转义符
```{r}
cat("\\") 
cat("\\n")
```

#### 1.3.7.1  字符常量
字符常量表

---

|字符常量|含义| 
|:--:|:--| 
| `\n` | 换行 |
| `\r` | 回车 |
| `\t` | 制表符 |
| `\b` | 退格 |
| `\a` | 报警(铃) |
| `\f` | 换页 |
| `\v` | 垂直制表符 
| `\\` | 反斜线\ |
| `\'` | 单引号 |
| `\"` | 双引号 |
| `\nnn` | 八进制 |
| `\xnn` | 十六进制 |
| ` | 反引号 |

### 1.3.8 字符串查询

> grep(pattern, x,
  ignore.case = FALSE, perl = FALSE, value = FALSE,
  fixed = FALSE, useBytes = FALSE, invert = FALSE
)

> grepl(pattern, x,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)


* `grep` 和 `grepl` 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 `pattern` 描述的内容
    * 

    * `ignore.case = TRUE` 表示忽略大小写
    * `fixed = TRUE` 表示启用 literal regular expression 字面正则表达式,相当于`%in%`,不使用正则表达。
    * `value=TRUE` 则返回下标对应的值,  `grep` 函数返回匹配到的字符串向量x的元素的下标

```{r}
grep("[a-z]", letters)                  # 返回下标位置
grep("[a-z]", letters, value = TRUE)    # 返回查询到的值
grep(x = c("apple", "banana"), pattern = "a", value = TRUE)
grep(x = c("apple", "banana"), pattern = "b", value = TRUE)

```
* `grepl` 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 `TRUE`，没有匹配到返回 `FALSE`
        * 在 `R` 中 `writeLines(c("a\\\\b", "a\\b"))` 分别表示 `a\\b` 和 `a\b`,
```{r}
grepl(x = c("apple", "banana"), pattern = "b")
grep(x = c("a\\\\b", "c\\d"), pattern = "\\", value = TRUE, fixed = TRUE)       # x向量中，包含'\\'的元素
grep(x = c("a\\\\b", "c\\d"), pattern = "\\\\", value = TRUE, fixed = FALSE)    # 使用正则表达式
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = TRUE)
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = FALSE)

```
* `regexpr` 函数返回一个整型向量，第一次匹配的初始位置，`-1` 表示没有匹配到，返回的属性 `match.length` 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，`-1` 表示没有匹配到  

> `regexpr(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)`

```{r}
text <- c("Hellow, Adam!", "Hi, Adam!", "How are you, Adam.", 'hellow, world')
a <- regexpr("Adam", text)
```
* `gregexpr` 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 `regexpr` 的返回值一样,




> `gregexpr(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)`

> `regexec(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
) `


### 1.3.9 字符串匹配
* `grep` 和 `agrepl` 函数做近似（模糊）匹配 (Approximate Matching or Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节.


> agrep(pattern, x, max.distance = 0.1, costs = NULL,
>      ignore.case = FALSE, value = FALSE, fixed = TRUE,
>      useBytes = FALSE)

> agrepl(pattern, x, max.distance = 0.1, costs = NULL,
>       ignore.case = FALSE, fixed = TRUE, useBytes = FALSE)

### 1.3.10 取子串

* `substr(x, start, stop)`从字符串`x`中取出从第`start`个到第`stop`个的子串，字符串第一个元素是索引是1。如
```{r}
substr('JAN07', 1, 3)
```
* 如果x是一个字符型向量，`substr`将对每个元素取子串。如

```{r}
substr(c('liull', 'caoxx'), 1, 3)
```
* 用`substring(x, start)`可以从字符串`x`中取出从第`start`个到末尾的子串。

```{r}
substring(c('liull', 'caoxx'), 4)
```
### 1.3.11 字符串替换功能

用`gsub()`可以替换字符串中的子串， 这样的功能经常用在数据清理中。如

```{r}
x <- 'chr1:1000:A>T'
gsub(':', ',', x, fixed=TRUE)  # x字符串中的冒号全部替换成逗号
```

## 1.4 R向量下标和子集

### 1.4.1 正整数下标

* 对向量x, 在后面加**方括号**和**下标**可以访问向量的元素和子集。修改元素不返回元素。

```{r}
x <- c(1, 4, 6.25)
x[2]                    # 取出第二个元素
x[2] <- 99              # 修改第二个元素， 不返回任何元素
x[c(1,3)]               # 取出第1、3号元素
x[c(1,3)] <- c(11,13)   # 修改第1、3号元素
x[c(1,3,1)]             # 下标可以重复

```
### 1.4.2 负整数下标
* **负下标**返回*扣除*相应的元素后的子集，
```{r}
x <- c(1, 4, 6.25)
x[-2]               # 返回删除第二个元素的剩余子集
x[-c(1,3)]          # 返回删除第1,3个元素的剩余子集
```
> 负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，x[c(1,-2)]没有意义。

### 1.4.3 空下标与零下标

* `x[]`表示取`x`的全部元素作为子集。 这与x本身不同，比如
```{r}
x <- c(1,4,6.25)
x[] <- 999 ; x
x <- 999 ; x
```
* `x[0]`是一种少见的做法， 返回类型相同、长度为零的向量， 如`numeric(0)`
```{r}
x <- c(1,4,6.25)
x[0]
```
### 1.4.4 下标超界

设向量x长度为, 则使用正整数下标时下标应在中取值。 
* 如果使用大于的下标， 读取时返回缺失值，并不出错。 
* 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如
```{r}
x <- c(1,4,6.25)
x[5]
x[5] <- 9 ; x
```
> 虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。

### 1.4.5 逻辑下标

```{r}
x <- c(1,4,6.25)
x[x > 3]                # 取出x的大于3的元素组成的子集
```
```{r}
f <- function(x){
    y <- numeric(length(x))
    y[x>= 0] <- 1
    y[x < 0] <- 0
    y
}
f(c(1,3))

```
* `ifelse()函数` : 向量化的逻辑选择，上面函数等价于`y <- ifelse(x>=0, 1, 0) `
* 缺失值的情况，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上`!is.na`前提， 如
```{r}
x <- c(1, 4, 6.25, NA)
x[!is.na(x) & x > 2]
```
### 1.4.6 `which()` `which.min()`  `which.max()`

* 函数`which()`可以用来找到满足条件的下标
*` which.min()`、`which.max()`求最小值的下标和最大值的下标， 不唯一时只取第一个。如

```{r}
x <- c(3, 4, 3, 5, 7, 5, 9)
x[which(x > 5)]     # 返回x向量大于5的值, 等价于 x[x>5]
x[which.min(x)]     # 返回x向量中最小值, 删除NA后的向量
x[which.max(x)]     # 返回x向量中最大值
```

### 1.4.7 元素名

* 向量可以为每个元素命名。如
```{r}
ages <- c("李明"=30, "张聪"=25, "刘颖"=28)                          # 或
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")    # 或
ages <- setNames(c(30, 25, 28), c("李明", "张聪", "刘颖"))
ages
```
* 可以用元素名或元素名向量作为向量的下标，这实际上建立了字符串到数值的映射表。如
```{r}
ages[c("李明", "刘颖")]
ages[c(1,3)]
``` 
* 用 `unname(x)` 返回去掉了元素名的x的副本，x向量值不变， 用 `names(x) <- NULL` 直接去掉x的元素名，不返回任何值。

```{r}
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")  
unname(ages)       # 直接返回
ages
```
```{r}
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")  
names(ages) <- NULL  # 不返回x的值
ages
```

### 1.4.8 向量下标作映射

R在使用整数作为向量下标时，允许使用重复下标， 这样可以把数组x看成一个的整数到 x[1], x[2], , x[n]的一个映射表, 其中是x的长度。

* sex为10个学生的性别（男、女），希望把每个学生按照性别分别对应到蓝色和红色。
```{r}
sex <- c("男", "男", "女", "女", "男", "女", "女", "女", "女", "男")
sex_color <- c("男"="blue", "女"="red")
cols <- sex_color[sex]; print(cols)

cols <- unname(cols) ; cols          # 去掉元素名
```

### 1.4.9 集合运算

向量x看成一个集合

*  `unique(x)` 可以获得x的唯一值
*  `a %in% x` 判断a的每个元素是否属于向量x，如
*  `intersect(x,y)`求交集
*  `union(x,y)` 求并集
*  `setdiff(x,y)`求差集，即x的元素中不属于y的元素组成的集合
*  `setequal(x,y)`判断两个集合是否相等， 不受次序与重复元素的影响

```{r}
unique(c(1, 5, 2, 5))
c(5,6) %in% c(1,5,2)
intersect(c(5, 7), c(1, 5, 2, 5))
union(c(5, 7), c(1, 5, 2, 5))
setdiff(c(5, 7), c(1, 5, 2, 5))
setequal(c(1,5,2), c(2,5,1))
```

## 1.5 数据类型性质

### 1.5.1 存储模式与基本类型

* `typeof()` 函数来返回一个变量或表达式的类型
```{r}
typeof(c(1:4))
typeof(c(1,4))
typeof(factor(c('F', 'M', 'M', 'F')))
```

 R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。

* 逻辑型（logical）
* 整数型（integer），只能用来储存正数。
    * 缺失值是NA
* 双整型（double），可正可负，可大可小，可含小数可不含，在数据科学里，它更常被称为数值型（numeric）
    * 缺失值是 `NA` 和 `NaN`也算是缺失值, `is.na()`判断是否`NA`或`NaN`； `is.nan()`判断是否`NaN`
    * `Inf`和`-Inf`不算是缺失值，·`is.infinite()`判断是否`Inf`或`-Inf`；
```{r}
is.integer(c(1, -3))    # 只能是整数，
is.integer(c(1L, -3L))  # 需要明确表明某些数值是整数， 可以在数值后面附加字母L
is.double(c(1, -3))
is.numeric(c(1, -3))    # integer和double内容都返回真值。
```
```{r}
c(-1, 0, 1)/0
is.na(c(-1, 0, 1)/0)
```
* 字符型（character）
* 复数型（complex）
* 原始型（raw), 是直接使用其二进制内容的类型
* `NULL`类型，只有唯一值是`NULL`值,表示不存在。 `NULL`长度为0， 不能有任何属性值。 
    * `is.null()`函数判断某个变量是否取NULL。

### 1.5.2 类型转换与类型升档

* 强制类型转换：`as.xxx()` 函数
* 隐藏类型转换：
    * 四则运算中数值会被统一转换为double类型， 
    * 逻辑运算中运算元素会被统一转换为logical类型。 
    * 逻辑值转换成数值时，TRUE转换成1， FALSE转换成0
```{r}
as.numeric(c(F, T))
as.character(c(1, pi))
typeof(3+4)
TRUE + 4
```
* 在用c()函数合并若干元素时， 如果元素基本类型不同， 将统一转换成最复杂的一个，复杂程度从简单到复杂依次为： `logical<integer<double<character`。 这种做法称为类型**升档**

```{r}
c(FALSE, 1L, 2.5, "3.6")     # 最复杂的是字符串型，最后都升挡为字符串型
```

* 不同类型参与要求类型相同的运算时， 也会统一转换为最复杂的类型， 也称为类型升档，

```{r}
TRUE + 10
paste("abc", 1)
```

### 1.5.3 属性
除了NULL以外， R的变量都可以看成是对象， 都可以有属性。 在R语言中， 属性是把变量看成对象后， 除了其存储内容（如元素）之外的其它附加信息， 如维数、类属等。 R对象一般都有`length`和`mode`两个属性。常用属性有`names`, `dim`，`class`等

#### 1.5.3.1 attribute 函数

`table()`函数用了输出其自变量中每个不同值的出现次数，称为频数。
```{r}
x <- table(c(1,2,1,3,2,1)); print(x)
attributes(x)
```
> dim和dimnames, 这是数组(array)具有的属性

attributes()函数修改属性， 如

```{r}
attributes(x) <- NULL; x    # 修改后x不再是数组，也不是table。
```

#### 1.5.3.2 attr(x,"属性名") 函数

读取或定义x的属性
```{r}
x <- c(1,3,5)
attr(x, "theta") <- c(0, 1)
print(x)

attr(x, "theta")   # 读取属性

```
> 可以让向量x额外地保存一个theta属性， 这样的属性常常成为“元数据”(meta data)， 比如， 用来保存数据的说明、模拟数据的真实模型参数

#### 1.5.3.3 names() 属性

* 有元素名的向量、列表、数据框等都有names属性， 许多R函数的输出本质上也是列表， 所以也有names属性。 用names(x)的格式读取或设定
* 对于没有元素名的向量x，names(x)的返回值是NULL
```{r}
x <- 1:5 ; y <- x^2 ; lmr <- lm(y ~ x)
print(names(lmr))
```

#### 1.5.3.4 dim() 属性

* `dim`属性的存在表明对象是矩阵或一维、多维数组。 如：
```{r}
x <- matrix(1:12, nrow=3, ncol=4)
attr(x, "dim") # 等同于dim(x)
```

### 1.5.4 类属性

* 函数class()可以返回变量类型的类属
```{r}
typeof(factor(c('F', 'M', 'M', 'F')))
## [1] "integer"
mode(factor(c('F', 'M', 'M', 'F')))
## [1] "numeric"
storage.mode(factor(c('F', 'M', 'M', 'F')))
## [1] "integer"
class(factor(c('F', 'M', 'M', 'F')))
## [1] "factor"
class(as.numeric(factor(c('F', 'M', 'M', 'F'))))
## [1] "numeric"
```

### 1.5.5 str()函数

用`print()`函数可以显示对象内容。 如果内容很多，显示行数可能也很多。 用`str()`函数可以显示对象的类型和主要结构及典型内容。例如

```{r}
s <- 101:200
attr(s,'author') <- '李小明'
attr(s,'date') <- '2016-09-12'
str(s)

print(s)
```

## 1.6 日期时间

### 1.6.1 日期和日期时间类型

* R日期可以保存为Date类型， 一般用整数保存，数值为从1970-1-1经过的天数。
* 特殊的POSIXct和POSIXlt
    * POSIXct把日期时间保存为从1970年1月1日零时到该日期时间的时间间隔秒数， 所以数据框中需要保存日期时用POSIXct比较合适， 需要显示时再转换成字符串形式；
    * POSIXlt把日期时间保存为一个包含年、月、日、星期、时、分、秒等成分的列表， 所以求这些成分可以从POSIXlt格式日期的列表变量中获得。

```{r}
library(lubridate)
```


### 1.6.2 从字符串生成日期数据

```{r}
lubridate::today()  # 返回当前日期: "2023-10-19"

lubridate::now()    # 返回当前日期时间: "2023-10-19 20:00:57 CST" , CST表示时区
```

* 用`lubridate::ymd()`, `lubridate::mdy()`, `lubridate::dmy()`将字符型向量转换为日期型向量
    * 在年号只有两位数字时，默认对应到1969-2068范围。
```{r}
lubridate::ymd(c("2023-10-19", "2023.10.1", "18-1-17", "20230110"))
lubridate::mdy(c("10-19-2023", "10.1.2023", "1-17-18", '01102023'))
lubridate::dmy(c("19-10-2023", "1.10.2023", "17-1-18", '10012023'))
```
* `lubridate`包的`ymd`、`mdy`、`dmy`等函数添加`hms`、`hm`、`h`等后缀， 可以用于将字符串转换成日期时间。 如
```{r}
lubridate::ymd_hms("1998-03-16 13:15:45", '20231019 20:17:59',  '20231019201759')
```

### 1.6.3 时区和时区转换

* 在`Date()`、`as.DateTime()`、`ymd()`等函数中， 可以用`tz=指定时区`， 
    * 北京时间可指定为`tz="Etc/GMT-8"`或 `tz="Asia/Shanghai"`。
```{r}
ymd_hms(c("1998-03-16 13:15:45", "2023-03-14 10:11:12"), tz="Asia/Shanghai")
```
* 为了将某个时间转换到指定的时区， 而不改变真正的时间， 用with_tz()函数
```{r}
with_tz(ymd_hms(c("1990-09-08 9:11:30", "2023-10-10 10:11:12"), tz="Etc/GMT-8"), tzone="UTC") # 改用东八区时间，原始时间减8小时
```

* 为了保持表面的时间（时钟显示的日期时间）不变， 但将**真正的时间修改到另外的时区**， 用`force_tz()`或`force_tzs()`， 其中`force_tzs()`可以将每个时间单独应用不同的时区。 如：
```{r}
force_tz(ymd_hms(c("20100908 101030", "20231019 101030"), tz="Etc/GMT-8"), tzone = "UTC")
```
```{r}
force_tzs(ymd_hms(c("1998-03-16 13:15:45", "2023-03-14 10:11:12"),
                  tz="Asia/Shanghai"), 
          tzones=c("Etc/GMT-6", "Etc/GMT-10"))
```
> 这将北京时间"1998-03-16 13:15:45"改成了东6区时间， 对应到UTC就是钟面时间减6， 所以13点变成7点， 将北京时间"2023-03-14 10:11:12"改成了东10区时间， 对应到UTC就是钟面时间减10，所以10点变成0点。 输入的日期中的时区"Asia/Shanghai"不起作用， 仅该时区的钟面时间起作用。


### 1.6.4 从数值生成日期数据

* `lubridate::make_date(year, month, day)`可以从三个数值构成日期向量。 如
```{r}
make_date(2023, 10,1)
```

* `lubridate::make_datetime(year, month, day, hour, min, sec)` 可以从最多六个数值组成日期时间， 其中时分秒缺省值都是0。 如
```{r}
c(make_datetime(2023, 10, 1, 10, 0 ,0), make_datetime(2023, 10, 1, 10, 0 ,0, tz="Etc/GMT-0"))
```

### 1.6.5 日期和日期时间之间的转换

* `lubridate::as_date()`可以将日期时间型转换为日期型，如
```{r}
as_date(ymd_hms("20231001 10:08:00"))
```

* `lubridate::as_datetime()`可以将日期型数据转换为日期时间型
```{r}
as.Date("2023-10-01") |> 
    as_datetime() |> 
    class()
```

### 1.6.6 日期显示格式

* 用`as.character()`函数把日期型数据转换为字符型
```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
as.character(x)
as.Date(c("12/6/2022", "1/1/2023"), format="%m/%d/%Y")
```

### 1.6.7 访问日期时间的组成值

* lubridate包的如下函数可以取出日期型或日期时间型数据中的组成部分：
    * `year()`取出年
    * `month()`取出月份数值
    * `mday()`取出日数值
    * `yday()`取出日期在一年中的序号，元旦为1
    * `wday()`取出日期在一个星期内的序号， 但是一个星期从星期天开始， 星期天为1,星期一为2，星期六为7。
    * `hour()`取出小时
    * `minute()`取出分钟
    * `second()`取出秒
```{r}
mday(as.POSIXct("2018-1-17 13:15:40"))
```
* lubridate的这些成分函数还允许被赋值， 结果就修改了相应元素的值，如
```{r}
x <- as.POSIXct("2018-1-17 13:15:40") ; year(x) <- 2000 ; x
```

### 1.6.8 日期舍入计算

lubridate包提供了floor_date(), round_date(), ceiling_date()等函数， 对日期可以用unit=指定一个时间单位进行舍入。 时间单位为字符串， 如seconds, 5 seconds, minutes, 2 minutes, hours, days, weeks, months, years等。

> 比如，以10 minutes为单位， 
>    * `floor_date()`将时间向前归一化到10分钟的整数倍， 
>    * `ceiling_date()`将时间向后归一化到10分钟的整数倍， 
>    * `round_date()`将时间归一化到最近的10分钟的整数倍， 时间恰好是5分钟倍数时按照类似四舍五入的原则向上取整。 例如

```{r}
x <- ymd_hms("2018-01-11 08:32:44")
floor_date(x, unit="10 minutes")
floor_date(x, "season")
```
### 1.6.9 日期计算

在lubridate的支持下日期可以相减， 可以进行加法、除法。 lubridate包提供了如下的三种与时间长短有关的数据类型：

* 时间长度(duration)，按整秒计算;
* 时间周期(period)，如日、周;
* 时间区间(interval)，包括一个开始时间和一个结束时间。

#### 1.6.9.1 时间长度

* R的POSIXct日期时间之间可以相减，如

```{r}
d1 <- ymd_hms("2023-10-24 0:0:0")
d2 <- ymd_hms("2000-01-01 12:0:5")
di <- d1 - d2; di                   # 结果是类型是difftime,  可以用as.double(di, units="secs")转化


as.double(di, units = "days")       # days / hours / mins / secs

as.duration(di)                     # 固定以秒作为基本单位



```

`
* lubridate的`dseconds()`, `dminutes()`, `dhours()`, `ddays()`, `dweeks()`, `dyears()`函数可以直接生成时间长度类型的数据，如

```{r}
dhours(1) + dseconds(5)
dhours(1)*10
d2 <- ymd_hms("2000-01-02 12:0:5")
d2 - dhours(5)      # 日期加或者减去一个时间长度， 结果严格按推移的秒数计算
d2 + ddays(10)


```

## 1.7 因子类型
### 1.7.1 因子
R中用因子代表数据中**分类变量**, 如性别、省份、职业。 有序因子代表有序量度，如打分结果，疾病严重程度等。

* 用`factor()`函数把字符型向量转换成因子，如

```{r}
x <- c("男", "女", "男", "男",  "女")
sex <- factor(x)
sex
attributes(sex)
```
> `read.csv()`函数的默认操作会把输入文件的字符型列自动转换成因子， 这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。 所以，在read.csv()调用中经常加选项`stringsAsFactors=FALSE`选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。 
> readr包的`read_csv()`函数， 这个函数读入CSV时不自动转换因子， 生成data.frame的替代类型tibble。


* 用`as.numeric()`可以把因子转换为纯粹的整数值，如 
```{r}
as.numeric(sex)
```
* 用`as.character()`可以把因子转换成原来的字符型，如
```{r}
as.character(sex)
```
* `factor()`的一般形式
    * `levels`自行指定各水平值, 不指定时由x的不同值来求
    * `labels`指定各水平的标签, 不指定时用各水平值的对应字符串
    * 
    
```{r}
# factor(x = character(), levels, labels = levels,
 #      exclude = NA, ordered = is.ordered(x), nmax = NA)
```

### 1.7.2 cut() 函数分段
* 连续取值的变量，可以用cut()函数将其分段， 转换成因子。
    * `breaks=n` 等间距分组,分组个数是n.
```{r}
set.seed(1)
x <- sort(round(rnorm(20), 2))
f <- cut(x, breaks=4); f
levels(f) <- c("a", "b", "c", "d"); f       # 修改水平标记
```
* 各组个数平均分组， 可以利用`quantile()`函数计算分位数作为分组
    * `oredered_result=TRUE`表示生成有序因子
```{r}
cu <- quantile(x, c(0, 1/4, 1/2, 3/4, 1))
cu[1] <- cu[1] - 0.01*(cu[5] - cu[1])
f2 <- cut(x, breaks=cu, oredered_result=TRUE)
levels(f2) <- c("a", "b", "c", "d"); f2
```
### 1.7.3 table() 统计因子各水平的出现次数
* 一般的向量统计每个不同元素的出现次数

```{r}
x <- c("男", "女", "男", "男",  "女")
sex <- factor(x)
table(sex)

```
### 1.7.4 tapply() 按照因子分组然后每组计算另一变量的概括统计

```{r}
h <- c(165, 170, 168, 172, 159)
tapply(h, sex, mean)
```
> 第一自变量h与与第二自变量sex是等长的， 对应元素分别为同一人的身高和性别， tapply()函数分男女两组计算了身高平均值。


### 1.7.5 forcats包的因子函数
https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact.html#summ-by-forcats



## 1.8 列表类型
### 1.8.1 列表
* 列表(list)类型来保存不同类型的数据, 一个主要目的是提供R分析结果输出包装。
* 列表的不同元素的类型可以不同, 列表不要求各列等长。

```{r}
rec <- list(name="李明", age=30,
  scores=c(85, 76, 90))
rec

typeof(rec)     # 查看类型
is.list(rec)    # 判断某个对象是否列表类型

vector("list", 5)   # 生成元素为空的长度为n的列表
```
### 1.8.2 列表元素访问
#### 1.8.2.1 查
* 方式1：**双层**中括号,返回子元素的实际类型
```{r}
rec[[3]]
rec[[3]][2]
rec[['age']]
typeof(rec[[1]])   # 返回 character
```

* 方式2：`$`访问
```{r}
typeof(rec$name)   # 返回 character
```

* 方式3：单中括号，取列表的子集，返回的结果是列表
```{r}
rec[3]
rec['age']
is.list(rec[1])
```

#### 1.8.1.2 元素名
* 列表一般都应该有元素名， 元素名可以看成是变量名， 列表中的每个元素看成一个变量。 用`names()`函数查看和修改元素名
```{r}
names(rec)                                       # 查看列表中所有的元素名
names(rec)[names(rec)=="scores"] <- "三科分数"   # 修改元素名
rec[["三科分数"]]
```
#### 1.8.2.3 修改列表元素内容
1. 修改已经存在元素

```{r}
rec[['三科分数']][2] <- 0
```

2. 给列表**不存在的元素**名定义元素值就添加了新元素
```{r}
rec[["身高"]] <- 175
rec

```
3. 某个**列表元素**赋值为`NULL`就删掉这个元素
```{r}
rec[["age"]] <- NULL
print(rec)
```
4. 在list()函数中允许定义元素为NULL，这样的元素是存在的
```{r}
li <- list(a=120, b="F", c=NULL); li
li['b'] <- list(NULL); li

```

### 1.8.3 列表类型转换
* 用`as.list()`把一个其它类型的对象转换成列表； 
* 用`unlist()`函数把列表转换成基本向量

```{r}
li1 <- as.list(1:3); li1
li2 <- list(x=1, y=c(2,3));unlist(li2)
```
### 1.8.4 连接列表
```{r}
li <- list()
li <- c(li, list(1:3))
li <- c(li, list(11:13))
li
```
### 1.8.5 返回列表的函数示例 - `strsplit()`
```{r}
x <- c("10, 8, 7", "5, 2, 2", "3, 7, 8", "8, 8, 9")
res <- strsplit(x, ","); res                # 返回列表
t(sapply(res, as.numeric))
```
> 列表、向量或数据帧作为输入，并以向量或矩阵的形式给出输出。
 
## 1.9 矩阵与数组
### 1.9.1 矩阵
矩阵用matrix函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素， 默认的存储次序为**按列**存储，用`byrow=TRUE`选项可以设置成**按行**填入。 
```{r}
A <- matrix(11:16, nrow=3, ncol=2,byrow = TRUE); print(A)
attributes(A)$dim    # 等价于 dim(A),返回A的维度
nrow(A)     # A的行数
ncol(A)     # A的列数
t(A)        # 返回A的转置
```
### 1.9.2 矩阵子集
#### 1.9.2.1 子集 
```{r}
A[1,] # 取出A的第一行，变成一个普通向量。 
A[,1] # 取出A的第一列，变成一个普通向量。 
A[c(1,3),1:2]    #取出指定行、列对应的子矩阵

```
#### 1.9.2.2 行列命名
```{r}
colnames(A) <- c('X', 'Y')        # 给矩阵每列命名， 也可以访问矩阵列名
rownames(A) <- c('a', 'b', 'c')   # 给矩阵每行命名， 也可以访问矩阵行名
A[c('a', 'c'), 'Y']
```
#### 1.9.2.3. `drop=FALSE`参数生成列向量

矩阵取子集时， 如果取出的子集仅有一行或仅有一列， 结果就不再是矩阵而是变成了R向量， R向量既不是行向量也不是列向量
```{r}
A[,1,drop=FALSE]
```

### 1.9.3 cbind()和rbind()函数

* 若x1, x2, x3是等长的向量， `cbind(x1, x2, x3)`把它们看成**列**向量并在一起组成一个矩阵。
```{r}
cbind(c(1,2), c(3,4), c(5,6))
cbind(A,Z=c(1,2,3))
```
* `cbind()`的自变量中也允许有标量， 这时此标量被重复使用
```{r}
cbind(1, c(1,-1,10))
```
* `rbind()`用法类似， 可以等长的向量看成行向量上下摞在一起， 可以是矩阵与长度等于矩阵列数的向量上下摞在一起， 向量长度为1也可以。

### 1.9.4 矩阵运算
#### 1.9.4.1 四则运算（+-*/）
1. 与标量,结果为每个元素进行相应运算
2. 两个同形状的矩阵进行加、减运算， 即对应元素相加、相减， 这就是线性代数中矩阵的加、减运算。
3. 两个同形状的矩阵进行乘、除运算， 即对应元素相乘、相除。

#### 1.9.4.2 矩阵乘法
用`%*%`表示矩阵乘法而不是用`*`表示， 注意矩阵乘法要求*左边的矩阵的列数*等于*右边的矩阵的行数*

```{r}
A <- matrix(11:16, nrow = 3, ncol = 2)
B <- matrix(c(1,1,-1,1), nrow = 2, ncol = 2)
A%*%B
```

#### 1.9.4.3 向量与矩阵向乘

矩阵与向量进行乘法运算时， 向量按需要解释成列向量或行向量。 当向量左乘矩阵时，看成行向量； 当向量右乘矩阵时，看成列向量
```{r}
c(1,1) %*% B    # 行向量 ： 1X2 %*% 2X2 == 1X2
B %*% c(1,1)    # 列向量 ： 2X2 %*% 2X1 == 1X2
```
#### 1.9.4.4 内积
设x, y是两个向量， 计算向量内积， 可以用sum(x*y)表示。

#### 1.9.4.5 外积
外积: `%o%`, 结果为矩阵。 `x %o% y`的第i行第j列元素等于x[i]乘以y[j]

### 1.9.5 apply()函数
1. `apply(A, 2, FUN)`把矩阵A的每一列分别输入到函数FUN中， 得到对应于每一列的结果
```{r}
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); apply(D, 2, sum)
```

2. `apply(A, 1, FUN)`把矩阵A的每一行分别输入到函数FUN中， 得到与每一行对应的结果
```{r}
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); apply(D, 1,mean)
```

3. 函数FUN返回多个结果， 则`apply(A, 2, FUN)`结果为矩阵， 矩阵的每一列是输入矩阵相应列输入到FUN的结果， 结果列数等于A的列数
```{r}
apply(D, 2, range)    # 返回每列的min和max,在同一列
```

4. 函数FUN返回多个结果， 为了对每行计算FUN的结果， 结果存入一个与输入的矩阵行数相同的矩阵， 应该用t(apply(A, 1, FUN))的形式
```{r}
t(apply(D, 1, range))
```

### 1.9.6 多维数组
矩阵是多维数组(array)的特例，也称二维数组。
定义语法：
    `数组名 <- array(数组元素, dim=c(第一下标个数, 第二下标个数, ..., 第s下标个数))`
其中数组元素的填入次序是第一下标变化最快， 第二下标次之， 最后一个下标是变化最慢的。 这种次序称为FORTRAN次序。

如:定义一个三维数组
```{r}
ara <- array(1:24, dim=c(2,3,4)); ara
```
### 1.9.7 列表类型的数组
矩阵一般用于数值计算，所以其元素一般是数值。 但是，在更复杂的编程场景中，可能需要在矩阵（或数组）元素中保存复杂结构， 比如， 每个元素是一个长度可变的向量。这时，可以将矩阵元素设为列表类型，但访问其元素需要使用部分列表访问语法格式。
```{r}
L <- matrix(list(), nrow=2, ncol=2); L          # s1. 生成未初始化的列表类型的矩阵
L[1,1] <- list(1:2) ; L[1,2] <- list(3:5) 
L[2,1] <- list(6:10) ; L[2,2] <- list(11:15)    # s2. 给每个矩阵元素赋值为仅有一个元素的列表：
L[2,2]                                     # s3. 元素为仅一个元素的列表
```
## 1.10 数据框
### 1.10.1 数据框定义
1. 数据框类似于一个矩阵，有个横行、个纵列， 但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。 同一列的数据类型相同。

函数`data.frame()`可以生成数据框，`data.frame()`函数会将字符型列转换成因子， 加选项`stringsAsFactors=FALSE`可以避免这样的转换.如:

```{r}
d <- data.frame(
    name=c("李明", "张聪", "王建"), 
    age=c(30, 35, 28), 
    height=c(180, 162, 175),
    stringsAsFactors=FALSE)
print(d)
```
#### 1.10.1.1 赋值
如果数据框的某一列为常数， 可以在data.frame()调用中仅给该列赋一个值， 生成的结果会自动重复这个值使得该列与其他列等长。
```{r}
d$age =1; print(d)
```

#### 1.10.1.2 行列数
* ``
```{r}
cat("数据框d的行数：", nrow(d), '\n')
cat("数据框d的列数/变量数：", ncol(d), length(d))
```
#### 1.10.1.3 列/变量名

数据框每列叫做一个变量， 每列都有名字，称为列名或变量名， 可以用`names()`函数和`colnames()函数访问
```{r}
names(d)
colnames(d)
rownames(d)
```
> 给`names(d)`或`colnames(d)`赋值可以修改列名。

```{r}
names(d) = c("姓名", "年龄","身高"); names(d)
names(d)[2] = "age" ; names(d)
```

#### 1.10.1.4 转换成数据框
* 用as.data.frame(x)可以把x转换成数据框。 
    1. 如果x是一个向量， 转换结果是以x为唯一一列的数据框。 
    2. 如果x是一个列表并且列表元素都是长度相同的向量， 转换结果中每个列表变成数据框的一列。
    3. 如果x是一个矩阵，转换结果把矩阵的每列变成数据框的一列。

数据框是一个随着R语言前身S语言继承下来的概念， 现在已经有一些不足之处， `tibble包`提供了`tibble`类， 这是数据框的一个改进版本

#### 1.10.1.5 数据框显示
* `knitr::kable()`使得数据框保存的表格显示更丰富。
```{r}
d <- data.frame(
    name=c("李明", "张聪", "王建"), 
    age=c(30, 35, 28), 
    height=c(180, 162, 175),
    stringsAsFactors=FALSE)
knitr::kable(d)
```

##### 1.10.1.5.1 数据框内容访问
* 数据框可以用矩阵格式访问
```{r}
d[2,3]    # 第2行, 第3列
d[,3]     # 第3列, 但是这种作法与tibble不兼容， 所以应避免使用。
d[[3]]    # 第3列
# 新增
d[['wight']] = c(50, 52, 51)    # 新增1列

```
* 按列名访问列可用如
```{r}
d[['age']]      # 访问age列
d[, 'age']      # 访问age列。用法与tibble不兼容，应避免使用。
d$age           # 访问age列
```

##### 1.10.1.5.2 子集

* 因为数据框的一行不一定是相同数据类型， 所以数据框的一行作为子集， 结果还是数据框，而不是向量。

```{r}
x <- d[2,] ; is.data.frame(x)
x
```
* 同时取行子集和列子集

```{r}
d[c(1,2), "age"]            # 因为只取了1个列，返回结果是向量
d[1:2, c("age", "height")]  # 返回结果是数据框
d[d[["age"]] >= 30,]        # 筛选年龄大于30的行
```
> 对一般的数据框， 可以在取子集的方括号内加上`drop=FALSE`选项， 确保取列子集的结果总是数据框。 
> 数据框的改进类型`tibble`在用`d[,ind]`这种语法取出列子集时保持为`tibble格式`， 为了取出`tibble`中的一列作为向量， 应该使用`d[[ind]]`这样的语法。



#### 1.10.1.6 数据框的行名

数据框每一行可以有行名， 这在原始的S语言和传统的R语言中是重要的技术， 但是在改进类型tibble中则取消了行名， 需要用行名实现的功能一般改用left_join()函数实现。 

* 用数据框的行名可以建立一个值到多个值的对应表。 比如，有如下的数据框：
    * 其中“出游”是每个年级安排的出游次数， 
    * “疫苗”是该年级有全体无计划免疫注射。 
    * 把年级变成行名，可以建立**年级**到**出游次数与疫苗注射**的对应表：
```{r}
dm <- data.frame(
  "年级"=1:6,
  "出游"=c(0, 2, 2, 2, 2, 1),
  "疫苗"=c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)
)
rownames(dm) <- dm[["年级"]]
dm[["年级"]] <- NULL
dm
```
* 设某个社区的小学中抽取的4个班的年级为 `c(2,1,1,3)`， 其对应的出游和疫苗注射信息可查询
```{r}
ind <- c(2,1,1,3)
xx <- dm[as.character(ind),]
rownames(xx) <- NULL;xx
```
`
* 这个例子可以不用行名而是用`match()`函数实现。 `match(x, table)`对x的每个元素返回其在table中出现的位置序号。 找不到的元素返回NA。 如：
```{r}
dm <- data.frame(
  "年级"=1:6,
  "出游"=c(0, 2, 2, 2, 2, 1),
  "疫苗"=c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)
)
ind <- match(c(2,1,1,3), dm[['年级']])
dm[ind,]
```
> 对于代替数据框的tibble类型， 如果要实现行名的功能， 可以将行名作为单独的一列， 然后用dplyr包的inner_join()、left_join()、full_join()等函数横向合并数据集。参考[1.9.1](#1.9.1)


#### 1.10.1.7 数据框与矩阵的区别
* 数据框不能作为矩阵参加矩阵运算。 需要时，可以用as.matrix()函数转换数据框或数据框的子集为矩阵。 如
```{r}
d2 <- as.matrix(d[,c("age", "height")])
d3 <- crossprod(d2); d3   # 这里crossprod(A)表示。A^TA
```

### 1.10.2 tibble类型
#### 1.10.2.1 生成方法
[全部数据](https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/Rbook-data.zip)

1. 文件读取</br>
tibble类型是一种改进的数据框。 `readr`包的`read_csv()`函数是`read.csv()`函数的一个改进版本， 它将CSV文件读入为tibble类型，如文件`class.csv`的读入:

```{r}
library(tibble)
library(readr)
# setwd("F:/Code/R/00.base/base_r_learn")
d.class <- read_csv("data/class.csv")
```

2. `tibble()`函数生成小的tibble </br>
```{r}
d.bp <- tibble(
    `序号` = c(1,5,6,9,10,15),
    `收缩压` = c(145, 110, "未测", 150, "拒绝", 115)) 
d.bp # knitr::kable(d.bp)
```

3. `readr::read_csv()`也支持从一个多行字符串直接读入数据， 如
```{r}
readr::read_csv("序号,收缩压
1,145
5,110
6,NA
9,150
10,NA
15,115
") #|> knitr::kable()
```
#### 1.10.2.2 类型
* `tibble`类型的类属依次为`spec_tbl_df`, `tbl_df`,` tbl`, `data.frame`：
```{r}
class(d.class)
```
* 用`as_tibble()`可以将一个数据框转换为`tibble类型`, `dplyr`包提供了`filter()`、`select()`、`arrange()`、`mutate()` 等函数用来对tibble选取行子集、列子集，排序、修改或定义新变量，




#### 1.10.2.3 列子集问题
* `d[,ind]`:**单中方括号**取列子集时， 即使仅取一列， 从tibble取出的一列结果仍是tibble而不是向量；
* 双方括号格式或$格式，返回向量。

#### 1.10.2.4  行名问题
tibble默认不使用行名(rownames)。 有行名的数据框用`as_tibble()`转换为tibble时， 可以用`rownames="变量名"`选项将行名转换成tibble的一列， 该列的变量名由选项值确定。

* 原来用行名完成的功能， 可以改用dplyr包的left_join()等函数， 这些函数进行数据框的横向连接。
* 旧式数据框支持行名，有如下的缺点：
    * 行名本身往往也是有效的数据，如身份证号， 将有效数据以数据框中的列和行名两种不同形式保存， 增加了复杂度；
    * 为了使用某些变量辨识不同的行（观测）， 行名也具有局限性： 行名必须是相互不同的， 必须是字符型， 而用来区分各个观测的变量有可能有多个， 也可能不是字符型。
    * 行名要求互不相同是有局限性的， 如果用来辨识各行的变量有重复值， 就可以构成对各行的一种自然的分组。


#### 1.10.2.5 tibble和数据框的转换
1. tibble 转化为 data.frame
    * 如果不需要添加行名， 则as.data.frame(dt)就可以转换为data.frame。
    * 如果需要添加行名， 设dt中第一列要转换为行名， 转化的模板为
```
df <- as.data.frame(dt[,-1])
rownames(df) <- dt[[1]]
```
    * 如果dt中要转化为行名的列为id列， 转化的模板为
```
df <- as.data.frame(dt[,-match("id", names(dt))]),
rownames(df) <- df[["id"]]
```

2. data.frame 转化为 tibble
    * 如果不需要保留行名， 则as_tibble(da)就可以。
    * 如果需要将行名转换为结果的一列， 模板为:`dt <- as_tibble(df, rownames="id")`, 则原来的行名变成了dt的id列
    * 如果转换成tibble后仍保留原来的行名:`dt <- as_tibble(df, rownames=NA)`
    
## 1.11 工作空间和变量赋值

### 1.11.1 工作空间
R把在命令行定义的**变量都保存到工作空间**中， 在退出R时可以选择是否保存工作空间
1. 用`ls()`命令可以查看工作空间中的内容。
    * 随着多次在命令行使用R， 工作空间的变量越来越多， 使得重名的可能性越来越大， 而且工作空间中变量太多也让我们不容易查看其内容。 
    * 在命令行定义的变量称为“全局变量”， 在编程实践中， 全局变量是需要慎用的。

2. 用`rm()`函数删除工作空间中的变量
```{r}
ls()
rm(A, d1)
rm(list = ls())    # 清除所以的变量
```
> 要避免工作空间杂乱， 最好的办法还是所有的运算都写到自定义函数中。 自定义函数中定义的变量都是临时的， 不会保存到工作空间中。 这样，仅需要时才把变量值在命令行定义， 这样的变量一般是读入的数据或自定义的函数 （自定义函数也保存在工作空间中）

```{r}
sandbox <- function(){
  cat('沙盘：接连的空行回车可以退出。\n')
  browser()
}
sandbox()
```
> 提示符变成了“Browser[n]”，其中n代表层次序号。 在这样的browser命令行中随意定义变量， 定义的变量不会保存到工作空间中。 用“Q”命令可以退出这个沙盘环境， 接连回车也可以退出。

---
待续
---


# 2.编程
## 2.1 输入与输出
### 2.1.1 简单输入输出
#### 2.1.1.1 `print()`函数

* 显示某个变量或表达式的值
* **命令行使用R时**， 直接以变量名或表达式作为命令可以起到用`print()`函数显示的相同效果
```{r}
y <- c(1,3,5) ; print(y[2:3])
```
#### 2.1.1.2 `cat()`函数

* 用`cat()`函数把字符串、变量、表达式连接起来显示， 其中变量和表达式的类型一般是标量或向量，不能是矩阵、列表等复杂数据
    * `cat()`显示中需要换行需要在自变量中包含字符串"\n"， 即换行符。
```{r}
cat("y =", y, "\n")   # 需要换行时, 需要添加 `\n`
```
* 添加`file=`选项,会覆盖的写入文件，如果从文件的末尾添加需要添加`append=TRUE`选项
```{r}
# cat("=== 结果文件 ===\n", file="res.txt")
# cat("x =", x, "\n", file="res.txt", append=TRUE)
```

#### 2.1.1.3 `save()`和`load()`函数

* `save()`命令要求把指定的若干个变量（直接用名字，不需要表示成字符串） 保存到用`file=`指定的文件中， 随后可以用`load()`命令恢复到工作空间中。
```{r}
# save(x, y, file="myvars20200315.RData")
# load("myvars20200315.RData")
```

#### 2.1.1.4 `scan()``函数

* 输出文本文件中的数值向量， 文件名用`file=`选项给出, `quite=TRUE`选项使得读入时不自动显示读入的数值项数
```{r}
#cat(1:12, "\n", file="tmp/x.txt")
#x <- scan("tmp/x.txt")
```

### 2.1.2 读取CSV文件

* `base_R`可以用`read.csv()`, `read.table()`, `read.delim`, `read.fwf()`等函数读入, 
    * 建议在`readr`包的支持下用`read_csv()`, `read_table2()`, `read_delim()`, `read_fwf()`等函数读入
    * `read.delim(file=, )`:第一个参数为读取的文件路径或者URL。
    * `read.fwf()`:读取表格或固定宽度格式的文本行到数据框
* `readr`的读入速度比基本R软件的read.csv()等函数的速度快得多，速度可以相差十倍，也不自动将字符型列转换成因子， 不自动修改变量名为合法变量名， 不设置行名。



#### 2.1.2.1 csv格式
* 中小规模的数据, CSV格式作为文件交换格式比较合适。兼容性强。大型的数据读入效率很低。
* CSV格式的文件用逗号分隔开同一行的数据项， 一般第一行是各列的列名（变量名）。
    * 数值型数据， 只要表示成数值常量形式即可。 
    * 字符型数据， 可以用双撇号包围起来， 也可以不用撇号包围。 但是， 如果数据项本身包含逗号， 就需要用双撇号包围
```{r}
# d <- read_csv("aa.csv")
```

#### 2.1.2.2 从字符串读入
```{r}
library(readr)
d.small <- read_csv("name,x,y
John, 33, 95
Kim, 21, 64
Sandy, 49, 100
");d.small
```

#### 2.1.2.3 `read_csv()`选项
> read_csv(
  file,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  id = NULL,
  locale = default_locale(),
  na = c("", "NA"),
  quoted_na = TRUE,
  quote = "\"",
  comment = "",
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = min(1000, n_max),
  name_repair = "unique",
  num_threads = readr_threads(),
  progress = show_progress(),
  show_col_types = should_show_types(),
  skip_empty_rows = TRUE,
  lazy = should_read_lazy()
)


1. `skip=`选项跳过开头的若干行


2.  当数据不包含列名时， 只要指定`col_names=FALSE`，变量将自动命名为`X1`, `X2`, `...`，也可以用`col_names=`指定各列的名字
```{r}
d.small <- read_csv("John, 33, 95
Kim, 21, 64
Sandy, 49, 100
", col_names=c("name", "x", "y") )
```


3. `locale =`指定编码，`readr`包的默认编码是`UTF-8`编码
    * `GBK`编码的文件需要使用下面的程序
```{r}
d <- read_csv("data/bp.csv", locale = locale(encoding = "GBK"))
```


4. `na = c("", "NA")`：空缺的值读入为缺失值， 将”NA”也读入为缺失值
    * 上面的bp.csv文件中， 先将血压列按字符型读入， 再增加一列转换为数值型的列，非数值转换为NA:
```{r}
d <- read_csv("data/bp.csv", locale=locale(encoding="GBK"))
d[["收缩压数值"]] <- as.numeric(d[["收缩压"]])
```


5. `col_types = cols()`各列类型设置
    * 默认情况下，`readr`包读取前1000行猜测合理的类型， 并在读取后显示猜测的每列类型。
    * 但是有可能类型改变发生在1000行之后。 col_types选项可以指定每一列的类型，
    * `cols()`函数可以用来规定各列类型， 并且有一个`.default`参数指定缺省类型,如`cols(.default = col_character())`
        * "col_double()", "col_integer()", "col_character()", "col_factor()", "col_date()", "col_datetime"
        * 对因子，需要在col_factor()中用`lelvels=`指定因子水平。
```{r}
d <- read_csv("data/bp.csv", locale=locale(encoding="GBK"),
    col_types=cols(
      `序号` = col_integer(),
      `收缩压` = col_character()
      ))
```
    * 当猜测的文件类型有问题的时候， 可以先将所有列都读成字符型， 然后用type_convert()函数转换， 
```{r}
d <- read_csv("data/bp.csv",
              col_types=cols(.default = col_character()))
d <- type_convert(d)
```


6. `n_max=` 指定读入多少行，通常用在测试大样本

#### 2.1.2.4 因子类型设置

```{r}
d.class <- read_csv("data/class.csv", 
                    col_types=cols(.default = col_double(),
                                   name = col_character(),
                                   sex = col_factor(levels=c("M", "F")) ))
str(d.class)
```
> 其中`str()`函数可以显示数据框的行数(obs.)和变量数(variables)， 以及每个变量（列）的类属等信息。

# 3. 数据整理 - `tidyverse`系统
## 3.1 tidyverse系统介绍
`tidyverse`包实际上就是一些常用R包的集合，包括`ggplot2（可视化`）、`dplyr（数据操作）`、`tidyr（数据对齐）`、`tibble（更现代的数据框）`、`stringr（字符串操作)`
* readr包用于读入数据， 
* tidyr包用于进行长、宽表转换，通常用于**行**数据整理。[tidyr官网](https://tidyr.tidyverse.org/reference/)
* dplyr包用于数据整理与汇总， 通常用于**行**数据整理。[dplyr官网](https://dplyr.tidyverse.org/reference/)
* purr包进行map-reduce类操作
* magrittr包管道符 %>%

数据集经常需要选**行子集**、选**列子集**、**排序**、**定义新变量**、横向**合并**、长宽转换等操作， 而且经常会用若干个连续的操作分步处理， R的管道运算符`|>`和`magrittr`包的`%>%`特别适用于这种分步处理。
```{r}
library(tidyverse)   # 载入tidyverse包， 则magrittr包，readr包，dplyr包和tidyr包都会被自动载入
```

* 数据集例子1
```{r}
d.class <- read_csv("data/class.csv", col_types=cols(.default = col_double(),
                                                     name=col_character(),
                                                     sex=col_factor(levels=c("M", "F"))
                                                     ))
```
> 这个数据框有19个观测， 有如下5个变量：name, sex, age, height, weight

* 数据集例子2

`NHANES`扩展包提供的`NHANES`， 这是一个规模更大的示例数据框， 可以看作是美国扣除住院病人以外的人群的一个随机样本， 有10000个观测，有76个变量， 主题是个人的健康与营养方面的信息。 仅作为教学使用而不足以作为严谨的科研用数据。 原始数据的情况详见http://www.cdc.gov/nchs/nhanes.htm

```{r}
if (require(NHANES)) {
  library(NHANES)
}else{
  install.packages('NHANES')
  library(NHANES)
}

print(dim(NHANES))
```
> 变量ID是受试者编号， SurveyYr是调查年份， 同一受试者可能在多个调查年份中有数据。 变量中包括性别、年龄、种族、收入等人口学数据， 包括体重、身高、脉搏、血压等基本体检数据， 以及是否糖尿病、是否抑郁、是否怀孕、已生产子女数等更详细的健康数据， 运动习惯、饮酒、性生活等行为方面的数据。 这个教学用数据集最初的使用者是Cashmere高中的Michelle Dalrymple 和新西兰奥克兰大学的Chris Wild。

###  3.1.1 查看数据框一般信息`dplyr::glimpse()`
* 显示数据框的大小、各列变量名、类型
```{r}
dplyr::glimpse(d.class)
```

###  3.1.2 `filter()`选择行子集
* 数据框的任何行子集仍为数据框，即使只有一行而且都是数值也是如此。
  * 行子集可以用行下标选取， 如`d.class[8:12,]`。 
  * `head()`取出数据框的前面若干行， 
  * `tail()`取出数据框的最后若干行。

`dplyr::filter()`函数可以按条件选出符合条件的行组成的子集
例1：从d.class中选出年龄在13岁和13岁以下的女生：
```{r}
d.class |> filter(age <=13, sex=="F") |> knitr::kable()
```
> 1. `filter(.data, ..., .by = NULL, .preserve = FALSE)` 
  * 第一个参数是要选择的数据框， 后续的参数是条件， 这些条件是需要同时满足的
> 2. `filter()`会自动舍弃行名， 如果需要行名只能将其转换成数据框的一列[1.10.2.5](./基础学习.html#tibble类型)。
> 3.  `filter()`的结果为行子集数据框。 用在管道操作当中的时候第一自变量省略（是管道传递下来的）。

###  3.1.2 `slice()` 按行序号选择行子集
基本R的utils包的函数head(x, n)可以用来选择数据框x前面n行， tail(x, n)可以用来选择数据框x后面n行，如：
* 如：得到第3:5行
```{r}
d.class |> head(n=5) |> tail(n=3) |> knitr::kable()
```

`dplyr`包的函数`slice(.data, ...)`可以用来选择指定序号的行子集， **正的序号**表示保留，**负的序号**表示排除
```{r}
d.class |> slice(3:5) |> knitr::kable()
```

其他几个slice_xxx()方便函数，用`prop=0.1`取代`n=5`表示按照比例提取行数。
* `slice_head(n=5)`提取前n行；
* `slice_tail(n=5)`提取最后n行；
* `slice_min(x, n=1)`提取x值最小的n行；
* `slice_max(x, n=1)`提取x值最大的n行；
* `slice_sample(n=5)`随机**无放回**抽取n行，也可以用`sample_n(size = n)`函数。

###  3.1.3 `sample_n()` 对观测随机抽样
`sample_n(tbl, size=n, replace = FALSE, weight = NULL)`函数
* `replace = FALSE`: 默认随机无放回抽取size行, `replace=TRUE`可以变成有放回抽样
* `weight=列名`：选项指定数据框中的一列作为抽样权重， 进行不等概抽样
```{r}
d.class |>
  sample_n(size = 3) |>
  knitr::kable()
```


### 3.1.4 `distinct()`去除重复行
`distinct(.data, ..., .keep_all = FALSE)`函数

* 筛选出性别与年龄的所有不同组合, 若要保留数据库的其它变量，添加参数`.keep_all=TRUE`：
```{r}
d.class |>
  distinct(sex, age, .keep_all = TRUE) |>
  knitr::kable()
```

### 3.1.5 `drop_na()`去除指定的变量有缺失值的行
`drop_na(data, ...)` 可以对数据框指定一到多个变量， 删去指定的变量有缺失值的行。 不指定变量时有任何变量缺失的行都会被删去。
```{r}
NHANES |> drop_na() |>  nrow()   # 查看得知：所有的行都有缺失值。
```

```{r}
NHANES |> drop_na(AlcoholDay) |> nrow()  # 剔除AlcoholDay列有缺失的观测并计数
```

### 3.1.6 `select()`选择列子集
#### 3.1.6.1 指定变量名
```{r}
d.class |>
  select(name, age) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.2 冒号表示列范围
```{r}
d.class |>
  select(name:age) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.3 数字序号表示列范围
```{r}
d.class |>
  select(1:3) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.4 负号写在前表示扣除

```{r}
d.class |>
  select(-name, -age) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.5 `where(示性函数)`选择满足条件的列
比如， 选择所有数据型列
```{r}
d.class |>
  select(where(is.numeric)) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.6 `all_of()` 引入已经保存变量的列名
如果要选择的变量名已经保存为一个字符型向量， 可以用all_of()函数引入，

* `all_of()`要求指定的所有变量名都是数据框中**存在**的；
```{r}
vars <- c("name", "sex")
d.class |>
  select(all_of(vars)) |>
  head(n=3) |>
  knitr::kable()
```
> R的字符串函数（如`paste()`）和正则表达式函数可以用来生成变量名子集， 然后在`select`中配合`all_of()`使用。


#### 3.1.6.7 `any_of()` 引入已经保存变量的列名
* 如果指定的变量有些可能是不存在的， 想将确实存在的那些变量选取进来， 应使用`any_of()`。
```{r}
vars <- c("name", "gender")
d.class |>
  select(any_of(vars)) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.8 `新变量=老变量`的格式同时改名
```{r}
d.class |>
  select(id = name, gender=sex) |>
  head(n=3) |>
  knitr::kable()
```

#### 3.1.6.9 其它
* `starts_with("se")`: 选择名字以“se”`开头的变量列；
* `ends_with("ght")`: 选择名字以“ght”`结尾的变量列；
* `contains("no")`: 选择名字中含有子串“no”`的变量列；
* `matches("^[[:alpha:]]+[[:digit:]]+$")`， 选择列名匹配某个正则表达式模式的变量列， 这里匹配前一部分是字母，后一部分是数字的变量名，如`abc12`。
* `num_range("x", 1:3)`，选择x1, x2, x3。
* `everything()`: 代指所有选中的变量， 这可以用来将指定的变量次序提前， 其它变量排在后面。

### 3.1.7 `pull()`取出单个变量为向量
* 选择单个变量并使得结果为普通向量
  * `pull()`可以指定单个变量名， 也可以指定变量序号，
  * 负的变量序号从最后一个变量数起。 
  * 缺省变量名和序号时取出最后一个变量。
  
```{r}
d.class |> 
  head(n=3) |>
  pull(name) |>
  paste(collapse=":")
```

* 如果要取出的变量名保存在一个字符型变量varname中
```{r}
varname <- "name"
d.class |> 
  head(n=3) |>
  select(one_of(varname)) |>
  pull() |>
  paste(collapse=":")
```

### 3.1.8 `arrange()`排序
* `desc()`包裹想要降序排列的变量
* 排序时不论升序还是降序， 所有的**缺失值**都自动排到末尾。
```{r}
d.class |>
  arrange(sex, desc(age)) |>
  knitr::kable()
```
* base_R的利用`order()`排序
```{r}
newdata <- d.class[order(d.class$sex, -d.class$age),] # 或
newdata <- d.class[order(d.class$sex, d.class$age, decreasing = c(FALSE,TRUE)),]
```

### 3.1.9 `rename()`修改变量名
* 用“新名字=旧名字”格式修改变量名
  * `rename()`函数可能出现在其它包中，保险起见写成`dplyr::rename()`。
```{r}
d2.class <- d.class |>
  dplyr::rename(h=height, w=weight)
```

### 3.1.10 `relocate()` 调整变量次序
`relocate(.data, ..., .before = NULL, .after = NULL)`
* `.before`: 指定一个变量名或变量序号， 使得指定的变量调整到此变量前面， 
* `.after`: 指定一个变量， 使得指定的变量调整到此变量后面

```{r}
d.class |>
  relocate(height, weight, .after=name) |>
  head(n=3) |>
  knitr::kable()
```

### 3.1.11 `mutate()`计算新变量
#### 3.1.11.1 一般
为数据框计算新变量， 返回含有新变量以及原变量的新数据框。
```{r}
d.class |>
  mutate(
    rwh=weight/height, 
    sexc=if_else(sex=="F", "女", "男")) |>
  head(n=3) |>
  knitr::kable()
```
* `if_else()`是`dplyr`包对基本R函数`ifelse()`的一个改进版本， 能够好处理**缺失值**和**结果类属**的问题。

#### 3.1.11.2 复杂
新变量计算比较复杂时，可以用多个语句组成复合语句
```{r}
d.class |>
  mutate(
    sexc={
      x <- rep("男", length(sex))       # 一个重要的r思想:全部赋值再修改
      x[!is.na(sex) & sex=="F"] <- "女"
      x
    } ) |>
  head(3)|>
  knitr::kable()
```

#### 3.1.11.3 统计函数结果
```{r}
d.class |>
  mutate(
    cheight = height - mean(height)) |>
  knitr::kable()
```

#### 3.1.11.4 新变量名与老变量名
`mutate(.data,.by = NULL,.keep = c("all", "used", "unused", "none"), .before = NULL, .after = NULL)`

* 新变量可以与老变量名相同， 这样就在输出中修改了老变量。
* `.keep="used"`仅保留新变量以及计算新变量时用到的变量。
* `.before=1`选项: 使得新定义的变量添加到原有变量的最前面
* `.after=变量名`: 使得新添加的变量放在指定的变量后面


> 新变量也可以直接为数据框的新变量赋值：

```{r}
d.class[["rwh"]] <- d.class[["weight"]] / d.class[["height"]]
```


### 3.1.12 `tranmute()`生成新变量的数据框
* 函数`transmute()`用法与`mutate()`类似， 但是仅保留新定义的变量， 不保留原来的所有变量
```{r}
d.class |>
  transmute(
    height_cm = round(height*2.54),
    weight_kg = round(weight*0.4535924),
    bmi =  weight_kg / (height_cm / 100)^2) |>
  head(n=3) |>
  knitr::kable()
```


```{r}
d.class |>
  lm(weight ~ height, data = _) |> coef()
```

### 3.1.13 `|>`管道连接多次操作
1. 管道操作的结果可以保存为新的`tibble`, 可以在前也可以在后
```{r}

class_F <- d.class |> filter(sex=="F") |> select(-sex, -age)  # 或
d.class |> filter(sex=="F") |> select(-sex, -age) -> class_F

# d.class |>
#   lm(weight ~ height, data = _)
```

### 3.1.14 `expand_grid()` 多个因素的试验设计搭配
在进行有多个因素的试验设计时， 往往需要生成多个因素完全搭配并重复的表格。
```{r}
tidyr::expand_grid(
  group=1:3,
  subgroup=1:2,
  obs=1:2) |>
  knitr::kable()
```
> 结果的数据框d有三个变量: group是大组，共分3个大组，每组4个观测； subgroup是子组，在每个大组内分为2个子组，每个子组2个观测。 共有个3X2X2 观测（行）。

### 3.1.15 `pivot_longer()`宽表转换为长表 
* **整洁数据**的要求是每行为一个观测， 每列为一个变量（属性
  * **宽表**: 每个受试者有多次随访的记录值，如果每个受试者的所有随访记录值存放在一个观测(行)中
  * **长表**: 每个受试者的随访记录值同一时间的多个属性用了多个观测保存


### 3.1.16 `pivot_wider()`长表转换为宽表 


### 3.1.17 拆分数据列
#### 3.1.17.1 `separate()`列拆分为各自的变量列
* 数据源
```{r}
d.sep <- read_csv(
"testid, succ/total
1, 1/10
2, 3/5
3, 2/8
")

d.sep |> 
    separate(
        `succ/total`,
        into=c("succ", "total"),
        sep="/",
        convert=TRUE) |> 
    knitr::kable()
```
* `into`指定拆分后新变量名
* `sep`指定分隔符
* `convert=TRUE`分割后的值自动转换为适当的类型 
* `extra`指出拆分时有多余内容的处理方法， 
* `fill`指出有不足内容的处理方法。

#### 3.1.17.2 `extract()`正则规则拆分
* 按照某种正则表达式表示的模式从指定列拆分出对应于正则表达式中捕获组的一列或多列内容
```{r}
dexp <- tibble(
  design = c("AA", "AB", "BA", "BB"),
  response = c(120, 110, 105, 95)) |> knitr::kable(dexp)
```
```{r}
dexp |>
    extract(
        design,
        into = c("fac1", "fac2"),
        regex = "(.)(.)"
    ) |>
    knitr::kable()
```

### 3.1.18 `unite()`合并数据列 - `separate()`的反向操作
* `tidyr::unite()`函数可以将同一行的两列或多列的内容合并成一列
```{r}
d.sep |>
    separate('succ/total', into = c("sicc", "total"), sep = "/", convert = TRUE) |>
    unite(ratio, sicc, total, sep=":") |>
    knitr::kable()
```

> unite()的第一个参数是要修改的数据框， 这里用管道|>传递进来， 
> 第二个参数是合并后的变量名（ratio变量）， 其它参数是要合并的变量名，
> sep指定分隔符。 
> 实际上用mutate()、paste()或者sprintf()也能完成合并

### 3.1.19 `bind_rows()`数据框纵向(行)合并
`dplyr`包的`bind_rows()`函数也可以对两个或多个数据框纵向合并。 要求变量集合是相同的，变量次序可以不同**(列名一样，顺序可以不同)**。
```{r}
d3.class <- d.class |>
  select(name, sex, age) |>
  filter(sex=="M")
d4.class <- d.class |>
  select(name, age, sex) |>
  filter(sex=="F")

d3.class |>
    bind_rows(d4.class) |>
    knitr::kable()
```

### 3.1.20 `bind_cols()`横向(列)合并 - 两个行数相同的数据框按行号对齐合并
#### 3.1.20.1 连接介绍
实际数据往往没有存放在单一的表中， 需要从多个表查找数据。 多个表之间的连接， 一般靠**关键列（key）**对准来连接。 连接可以是一对一的， 一对多的。 多对多连接应用较少， 因为多对多连接是所有两两组合。</br>

在规范的数据库中，每个表都应该有主键， 这可以是一列，也可以是多列的组合。 为了确定某列是主键， 可以用count()和filter()，如

```{r}
d.class |>
  count(name) |>
  filter(n>1) |>
  nrow()
```
> 没有发现重复出现的name， 说明d.class中name可以作为主键

#### 3.1.20.2 `inner_join()`一对一内连接
例子：为了演示一对一的横向连接， 我们将d.class取11和12岁的子集， 然后拆分为两个数据集d1.class和d2.class, 两个数据集都有主键name， d1.class包含变量name, sex, d2.class包含变量name, age, height, weight, 并删去某些观测：
```{r}
d1.class <- d.class |>
  filter(age <= 12) |>
  select(name, sex) |>
  filter(!(name %in%  "Sandy"))
d2.class <- d.class |>
  filter(age <= 12) |>
  select(name, age, height, weight)
```
用`dplyr`包的`inner_join()`函数将两个数据框按**键值**横向合并， 仅保留能匹配的观测。因为d1.class中丢失了Sandy的观测， 所以合并后的数据框中也没有Sandy的观测：
```{r}
d1.class |>
    inner_join(d2.class) |>
    knitr::kable()
```
* 横向连接自动找到了共同的变量name作为连接的键值， 
    * 可以在`inner_join()`中用`join_by(键)`指定键值变量名， 
        * 如果有不同的键名， 可以用`join_by(左键 == 右键)`的格式指定， 这里用了==是因为这类似于SQL中左右连接时的连接条件， 这里是相等情况下的连接， 而R中用两个等于号表示是否相等的判断。
* 如果你确信左右表的连接都是**一对一**的， 如果出现重复匹配意味着数据错误， 可以在`inner_join()`中加选项`multiple = "error"`， 其默认值是`"warn"`， 即会显示警告信息。
* 如果左右表的**一对一**连接不应该有遗漏， 如果有任何不匹配意味着数据有错， 可以在`inner_join()`中加选项`unmatched = "error"`， 其默认值是`"drop"`, 即会删除不匹配的行。。

#### 3.1.20.3 `left_join()` 多对一左连接








































































































































































