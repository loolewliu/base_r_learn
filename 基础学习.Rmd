---
title: "基础学习"
author: 
  - "liulifeng@163.com" #作者信息
  - "`r Sys.Date()`" #自动获取当前日期
output: 
  prettydoc::html_pretty:
    #可以从齿轮-Output Options中设置
    css: sspai.css #css模板，定义整个文档的格式，比如一级标题的字体字号等
    highlight: tango #代码高亮风格
    # number_sections: yes #是否自动按节编号
    # theme: cayman # 1
    # theme: tactile #2
    # theme: architect #3
    theme: leonids #4
    # theme: hpstr #5
    toc: yes #是否自动生成目录
---

# 0. base-r

## 0.1 


# 1.数据机构
* 数据类型
    * 数值型：数值可以用于直接结算，加减乘除
    * 字符串型：可以进行连接、转换、提取等
    * 逻辑型：或真或假
    * 日期型等 
* 数据结构
    * 向量
    * 矩阵
    * 数据库
    * 多维数组
    * 列表
    * 对象
    

## 1.1 数值型向量

**向量**是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。<br>

用c()函数把多个元素或向量组合成一个向量。如

```{r}
 # 返回x的长度, 
length(c(1,2,3))
```

```{r}
# 初始化一个指定元素个数而元素都等于零的数值型向量
numeric(3)
```

### 1.1.1 标量与标量之间运算

```{r}
# + - * / ^ 加减乘除乘方
2+1
2-1
3*3
3/2
2^3

# %/% 整除 %%求余
5 %/% 3
5 %% 3
```


```{r}
# 圆括号()改变运算的先后次序
1.5 + 2.3 - (0.6 + 0.4)*1.5 - 1.5/0.5 + 2^3
```

### 1.1.2 向量与标量之间运算


向量与标量的运算为每个元素与标量的运算

```{r}
x <- c(1,20)
x+2
x-2
x*2
x/2
x^2
x%/%2
x%%2
```
 四则运算时如果有缺失值，缺失元素参加的运算相应结果元素仍缺失。 如

```{r}
c(1,NA,3) * 2
```

### 1.1.3 等长向量运算

对应元素两两运算
```{r}
x <- c(1,10)
y <- c(2,9)
x + y
x - y
x / y
```

### 1.1.4 不等长向量运算

* 长度为倍数关系，规则是每次从头重复利用短的一个。 如
```{r}
x <- c(1,3)
y <- c(2,4,6,8)

x + y
x - y
```

* 两个向量的长度不是倍数关系，会给出警告信息。如
```{r}
c(1,2) + c(1,2,3)
```

### 1.1.5 向量化函数 `help.start()`

查看这些基础的数学函数的列表，运行命令`help.start()`， 点击链接“Search Engine and Keywords”， 找到“Mathematics”栏目， 浏览其中的“arith”和“math”链接中的说明。 常用的数学函数有
```{r}
# 舍入 ceiling, floor, round, signif, trunc, zapsmall

ceiling(c(1.5, -1.2))     # 向上取整
floor(c(1.5, -1.2))       # 向下取整
round(c(pi), digits = 2)  # 四舍五入保留小数点2位
signif(c(pi), digits = 2) # 四舍五入保留2位有效数字
trunc(pi * 10^(-2:1))     # 保留整数部分
```

```{r}
# 符号函数 sign  返回值：1 代表正数，-1 代表负数
x <- c(1, 5, 0, -10, 100, -20, 10, -69)
cat("Sign of elements of vector x:", sign(x), "\n")
```
```{r}
# 绝对值函数
abs(c(pi, -pi))
```
```{r} 
# sqrt 平方根  x^(1/3) 立方根
x <- seq(1,10,2)
sqrt(x)
x^(1/2)
```

```{r}
# 对数与指数函数 log, exp, log10, log2
log(4,base = 2) # 以2为底4的对数
log2(4)         # 以2为底4的对数
log10(100)      # 以10为底100的对数
exp(1)          # e的多少次方
```

```{r}
# 三角函数， 反三角函数
sin(pi/6) 
cos(pi/6)
tan(pi/6)
asin(0.5)
acos(0.5)
atan(1)
#atan2(1)

```
### 1.1.6 排序函数

* `sort(x)`返回排序结果。 
* `rev(x)`返回把各元素排列次序反转后的结果。
* `order(x)`返回排序用的下标。如

```{r}
x <- c(11,44,22)
sort(x)                     # 默认升序(decreasing = FALSE)，
sort(x, decreasing = TRUE)  # 设置位降序
rev(sort(x))                # 等价与  sort(x, decreasing = TRUE)  # 设置位降序
order(x)                    # 结果中的2是x的最大元素44所在的位置下标
x[order(x)]                 # 等价 sort(x) 
```
### 1.1.7 统计函数


```{r}
# 简单统计函数 max() min() range() sum() mean() sd() var()  median() quantile()
x <- c(1:10)
max(x)      # 最大值
min(x)      # 最小值
range(x)    # 返回2个值，分别是最小值和最大值
sum(x)      # 求和
mean(x)     # 均值
var(x)      # 方差
sqrt(var(x))# 标准差
sd(x)       # 标准差
median(x)   # 中位数
quantile(x) # 四分卫位数
quantile(x,c(0.4, 0.8)) # 指定百分比的分位数
prod(x)     # 连乘积
```

cumsum和cumprod计算累加和累乘积。

```{r}
cumsum(1:5)   # 累加和
cumprod(1:5)  # 累乘积 
```
### 1.1.8 生成序列函数
`seq函数`是冒号运算符的推广。 比如，`seq(5)`等同于1:5。 `seq(2,5)`等同于2:5。

```{r}
# seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),length.out = NULL, along.with = NULL, ...)

seq(from=1, to=10, by=2) # 从1到10 间隔为2
seq(1,10,2) # 简写形式
seq(from=1, to=10, length.out=3) # [1,10]之间取3个数，等间距
```

```{r}
# rep 重复元素
rep(c(1,2), time=2) # 向量重复出现2次
rep(c(1,2), time=2, each=2) # 向量的每个元素重复2遍， 再重复的元素在重复2遍

```

小问题： 1:5和seq(5)的结果是整型（integer）的， c(1,3,5)和seq(1, 5, by=2)的结果是浮点型（double）的。


## 1.2 逻辑型向量及运算

### 1.2.1 逻辑型向量与比较运算符


逻辑型是R的基本数据类型之一，只有两个值**TRUE**和**FALSE**, 缺失时为**NA**。逻辑值一般在比较中产生。向量比较的结果为逻辑向量。

```{r}
sele <- (log10(15) < 2); print(sele)
c(1,3,4) > 3
c(1:4) > c(4:1)
```

> 从例子可以看出，向量比较也遵从R的向量间运算的一般规则： 向量与标量的运算是向量每个元素与标量都分别运算一次， 等长向量的运算时对应元素的运算， 不等长但长度为倍数关系的向量运算是把短的从头重复利用。


* 与NA比较产生NA，如
```{r}
c(1, NA, 3) > 2    # [1] FALSE    NA  TRUE
NA == NA           # [1] NA
```

* 为了判断向量每个元素是否NA， 用is.na()函数，如
```{r}
is.na(c(1, NA, 3))    # [1] FALSE  TRUE FALSE
```

* 用`is.finite()`判断向量每个元素是否**Inf**值

**比较运算符**
<   <=  >  >=  ==  !=  %in%   
分别表示小于、小于等于、大于、大于等于、等于、不等于、属于。 要注意**等于比较**用了两个等号

* %in%是特殊的比较， x %in% y的运算把向量y看成集合，运算结果是一个逻辑型向量，x向量中的每个值是否属于y向量。如
```{r}
c(1, 3) %in% c(2,3,4)       # [1] FALSE  TRUE
c(1,3) %in% c(NA, 3, 4)     # [1] FALSE  TRUE
c(NA,3) %in% c(NA, 3, 4)    # [1] TRUE TRUE
```

函数**match(x, y)**起到和x %in% y运算类似的作用， 但是其返回结果不是找到与否， 而是对x的每个元素， 找到其在y中首次出现的下标，找不到时取缺失值，如
```{r}
match(c(1, 3), c(2,3,4,3))  ## [1] NA  2
```

### 1.2.2 逻辑运算

* 逻辑运算符为`&`, `|`和`!`, 分别表示“同时成立”、“两者至少其一成立”、“条件的反面”。运算的先后次序可以用圆括号()指定.

> age<=3 & sex=='女'表示女婴,;
> age<=3 | sex=='女'表示婴儿或妇女;
> !(age<=3 | sex=='女')表示既非婴儿也非妇女

* 在右运算符是缺失值时， 如果左运算符能够确定结果真假， 可以得到非缺失的结果。 例如，`TRUE | NA`为TRUE,` FALSE & NA`为FALSE。 不能确定结果时返回`NA`， 比如， `TRUE & NA`为NA, `FALSE | NA`为NA。

* 标量之间的逻辑比较，`&&`和`||`分别为短路的标量逻辑与和短路的标量逻辑或
`if(TRUE || sqrt(-1)>0) next` ,其中的`sqrt(-1)`部分不会执行。 其中条件的结果为`TRUE`, 第二部分没有参加计算， 否则第二部分的计算会发生函数自变量范围错误。

#### 1.1.2.3 逻辑运算函数

`if`结构、`while`结构都需要**逻辑标量**而且不能是缺失值。 这时，应该对缺失值结果单独考虑。

若`cond`是逻辑向量
* 用`all(cond)`测试`cond`的所有元素为真； 
* 用`any(cond)`测试`cond`至少一个元素为真。
`cond`中允许有缺失值，结果可能为缺失值。 如

```{r}
c(1, NA, 3) > 2         ## [1] FALSE    NA  TRUE
all(c(1, NA, 3) > 2)    ## [1] FALSE
any(c(1, NA, 3) > 2)    ## [1] TRUE
all(NA)                 ## [1] NA
any(NA)                 ## [1] NA
```
函数`which()`返回真值对应的所有下标，如
```{r}
which(c(T, F, T, NA))
which(c(2:5) > 4)
x <- c(2, 3, 5, 7, 11, 13);x <- x[-which(x == 5)]
```
函数`identical(x,y)`比较两个R对象`x`与`y`的内容是否完全相同， 结果只会取标量`TRUE`与`FALSE`两种。 如
```{r}
identical(c(1,2,3), c(1,2,NA))
identical(c(1L,2L,3L), c(1,2,3))   # 结果假值是因为前一向量是整数型， 后一向量是实数型。
```
函数`duplicated()`返回每个元素是否为重复值的结果，用函数`unique()`可以返回去掉重复值的结果。如：

```{r}
duplicated(c(1,2,1,3,NA,4,NA))
unique(c(1,2,1,3,NA,4,NA))
```

## 1.3 字符型数据及处理

### 1.3.1 字符型向量
元素为字符串的向。字符串在程序中写成用两个双撇号包围或者用两个单撇号包围的内容。 如
```{r}
s <- c('a', "b", NA, FALSE, '', '小明') ; cat(s)
```
> 注意**空字符串**并不能自动认为是缺失值， 字符型的缺失值仍用NA表示。

### 1.3.2 转义字符和原始字符串

* 用**反斜杠**在前面标明， 称为“转义”，如：
```{r}
cat("\"\n")
```

* 当需要转义的内容较多时， 可以使用原始字符串(raw string)， 方法是用`r"(...)"`的格式， 其中`...`是实际内容。如：

```{r}
cat(r"(F:\Code\R\00.base\n)")    # 注意其中\n也被当作普通字符解释了， 不再当作换行符。
```

原始字符串如果内容中包含了圆括号， 可以将边界的圆括号改为方括号[]或者大括号{}。 如果这样也不能避免歧义， 可以在开始和结尾加上相同个数的减号， 格式为`r"--(...)--"`， 其中...为实际内容， 减号个数可以根据需要增加。
```{r}
cat(r"--{my_str()}--")  # 等价于 cat(r"(my_str())")

```

### 1.3.3 字符数统计

* `nchar()` 字符串向量中每个元素的字符个数
* `length()` 向量中元素的个数，即向量的长度
```{r}
nchar(R.version.string)      # R version 4.3.1 (2023-06-16 ucrt)
nchar(NA)                    # NA
nchar(pi)                    # 16
```

> `R.version`返回一个列表

```{r}
R.version
R.version$language
```
### 1.3.4 转换大小写

* `toupper()`函数把字符型向量内容转为大写
* `tolower()`函数转为小写。

```{r}
toupper(c('appLE', 'Red'))
tolower(c('appLE', 'Red'))

x <- 'JAn'; toupper(x) == "JAN"
```

### 1.3.5 字符串的连接

* `paste()`用来连接两个字符型向量， 元素一一对应连接， 默认用空格连接(`seq = " "`)。
    * `sep=`指定分隔符。
    * `collapse=`参数可以把字符型向量的各个元素连接成一个单一的字符串。
```{r}
paste(c('ab', 'cd'), c('ef', 'gh'))     # 等价于 c("ab ef", "cd gh")
paste('x', 1:3, sep="")                 # 等价于c("x1" "x2" "x3")
paste('x', 1:3, collapse = "", sep = "")# 等价于c("x1x2x3")
```
* `paste0()` 相当于 `sep` 设为空，没有连接符.
```{r}
paste0("A", "B")
paste0(c("A", "B", "C"), 1:3)
paste0(c("A", "B", "C"), 1:3, collapse = ";")
```
    
### 1.3.6 字符串拆分
`strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)` <br/>

* `x `是被拆分的字符串向量，其每个元素都会被拆分，
* `split` 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。
* `fixed = FALSE` 表示正则表达式匹配，而 `fixed = TRUE` 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。
* 使用 `perl = TRUE` 使用`perl`语言正则语法，可以提高运算速度
* `useBytes` 设置是否按照逐个字节地进行匹配，默认不按照字节逐个匹配


```{r}
x <- c(as = "abcdef", qu = "merry", "yuiop[", "b", "plot")
strsplit(x, 'e')   # 返回列表的字符串
strsplit("a.b.c", ".", fixed = TRUE)    # 按点号拆分, 等价于 strsplit("a.b.c", "\\.") 等价于 strsplit("a.b.c", "\\.", perl = TRUE)
```

* 一个将字符串逆序的函数

```{r}
str_rev <- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse = "")
str_rev(c("abc", "Statistics"))
```

### 1.3.7 正则表达式

R 内置的三种匹配模式 <br>
1. `fixed = TRUE` : 字面意思匹配,不使用正则表达式 <br>
2. `perl = TRUE`  : 使用 Perl 正则表达式 <br>
3. `fixed = FALSE, perl = FALSE` : 使用 POSIX 1003.2 extended 正则表达式 (默认设置). <br>

正则表达式 (regular expression，简称 regexp)
R 内支持正则表达式的函数有 `grep`、`grepl`、`sub`、`gsub`、`regexpr`、`gregexpr` 、 `regexec` 和 `strsplit`。<br>
函数 `apropos`，`browseEnv`，`help.search`，`list.files` 和 `ls` 是通过函数 `grep` 来使用正则表达式的，它们全都使用 extended regular expressions
* 反斜杠 `\` 本身是转义符
```{r}
cat("\\") 
cat("\\n")
```

#### 1.3.7.1  字符常量
字符常量表

---

|字符常量|含义| 
|:--:|:--| 
| `\n` | 换行 |
| `\r` | 回车 |
| `\t` | 制表符 |
| `\b` | 退格 |
| `\a` | 报警(铃) |
| `\f` | 换页 |
| `\v` | 垂直制表符 
| `\\` | 反斜线\ |
| `\'` | 单引号 |
| `\"` | 双引号 |
| `\nnn` | 八进制 |
| `\xnn` | 十六进制 |
| ` | 反引号 |

### 1.3.8 字符串查询

> grep(pattern, x,
  ignore.case = FALSE, perl = FALSE, value = FALSE,
  fixed = FALSE, useBytes = FALSE, invert = FALSE
)

> grepl(pattern, x,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)


* `grep` 和 `grepl` 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 `pattern` 描述的内容
    * 

    * `ignore.case = TRUE` 表示忽略大小写
    * `fixed = TRUE` 表示启用 literal regular expression 字面正则表达式,相当于`%in%`,不使用正则表达。
    * `value=TRUE` 则返回下标对应的值,  `grep` 函数返回匹配到的字符串向量x的元素的下标

```{r}
grep("[a-z]", letters)                  # 返回下标位置
grep("[a-z]", letters, value = TRUE)    # 返回查询到的值
grep(x = c("apple", "banana"), pattern = "a", value = TRUE)
grep(x = c("apple", "banana"), pattern = "b", value = TRUE)

```
* `grepl` 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 `TRUE`，没有匹配到返回 `FALSE`
        * 在 `R` 中 `writeLines(c("a\\\\b", "a\\b"))` 分别表示 `a\\b` 和 `a\b`,
```{r}
grepl(x = c("apple", "banana"), pattern = "b")
grep(x = c("a\\\\b", "c\\d"), pattern = "\\", value = TRUE, fixed = TRUE)       # x向量中，包含'\\'的元素
grep(x = c("a\\\\b", "c\\d"), pattern = "\\\\", value = TRUE, fixed = FALSE)    # 使用正则表达式
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = TRUE)
grepl(x = "a\\\\b", pattern = "\\\\\\\\", fixed = FALSE)

```
* `regexpr` 函数返回一个整型向量，第一次匹配的初始位置，`-1` 表示没有匹配到，返回的属性 `match.length` 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，`-1` 表示没有匹配到  

> `regexpr(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)`

```{r}
text <- c("Hellow, Adam!", "Hi, Adam!", "How are you, Adam.", 'hellow, world')
a <- regexpr("Adam", text)
```
* `gregexpr` 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 `regexpr` 的返回值一样,




> `gregexpr(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
)`

> `regexec(pattern, text,
  ignore.case = FALSE, perl = FALSE,
  fixed = FALSE, useBytes = FALSE
) `


### 1.3.9 字符串匹配
* `grep` 和 `agrepl` 函数做近似（模糊）匹配 (Approximate Matching or Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节.


> agrep(pattern, x, max.distance = 0.1, costs = NULL,
>      ignore.case = FALSE, value = FALSE, fixed = TRUE,
>      useBytes = FALSE)

> agrepl(pattern, x, max.distance = 0.1, costs = NULL,
>       ignore.case = FALSE, fixed = TRUE, useBytes = FALSE)

### 1.3.10 取子串

* `substr(x, start, stop)`从字符串`x`中取出从第`start`个到第`stop`个的子串，字符串第一个元素是索引是1。如
```{r}
substr('JAN07', 1, 3)
```
* 如果x是一个字符型向量，`substr`将对每个元素取子串。如

```{r}
substr(c('liull', 'caoxx'), 1, 3)
```
* 用`substring(x, start)`可以从字符串`x`中取出从第`start`个到末尾的子串。

```{r}
substring(c('liull', 'caoxx'), 4)
```
### 1.3.11 字符串替换功能

用`gsub()`可以替换字符串中的子串， 这样的功能经常用在数据清理中。如

```{r}
x <- 'chr1:1000:A>T'
gsub(':', ',', x, fixed=TRUE)  # x字符串中的冒号全部替换成逗号
```

## 1.4 R向量下标和子集

### 1.4.1 正整数下标

* 对向量x, 在后面加**方括号**和**下标**可以访问向量的元素和子集。修改元素不返回元素。

```{r}
x <- c(1, 4, 6.25)
x[2]                    # 取出第二个元素
x[2] <- 99              # 修改第二个元素， 不返回任何元素
x[c(1,3)]               # 取出第1、3号元素
x[c(1,3)] <- c(11,13)   # 修改第1、3号元素
x[c(1,3,1)]             # 下标可以重复

```
### 1.4.2 负整数下标
* **负下标**返回*扣除*相应的元素后的子集，
```{r}
x <- c(1, 4, 6.25)
x[-2]               # 返回删除第二个元素的剩余子集
x[-c(1,3)]          # 返回删除第1,3个元素的剩余子集
```
> 负整数下标不能与正整数下标同时用来从某一向量中取子集， 比如，x[c(1,-2)]没有意义。

### 1.4.3 空下标与零下标

* `x[]`表示取`x`的全部元素作为子集。 这与x本身不同，比如
```{r}
x <- c(1,4,6.25)
x[] <- 999 ; x
x <- 999 ; x
```
* `x[0]`是一种少见的做法， 返回类型相同、长度为零的向量， 如`numeric(0)`
```{r}
x <- c(1,4,6.25)
x[0]
```
### 1.4.4 下标超界

设向量x长度为, 则使用正整数下标时下标应在中取值。 
* 如果使用大于的下标， 读取时返回缺失值，并不出错。 
* 给超出的下标元素赋值， 则向量自动变长， 中间没有赋值的元素为缺失值。 例如
```{r}
x <- c(1,4,6.25)
x[5]
x[5] <- 9 ; x
```
> 虽然R的语法对下标超界不视作错误， 但是这样的做法往往来自不良的程序思路， 而且对程序效率有影响， 所以实际编程中应避免下标超界。

### 1.4.5 逻辑下标

```{r}
x <- c(1,4,6.25)
x[x > 3]                # 取出x的大于3的元素组成的子集
```
```{r}
f <- function(x){
    y <- numeric(length(x))
    y[x>= 0] <- 1
    y[x < 0] <- 0
    y
}
f(c(1,3))

```
* `ifelse()函数` : 向量化的逻辑选择，上面函数等价于`y <- ifelse(x>=0, 1, 0) `
* 缺失值的情况，如果逻辑下标中有缺失值， 对应结果也是缺失值。 所以，在用逻辑下标作子集选择时， 一定要考虑到缺失值问题。正确的做法是加上`!is.na`前提， 如
```{r}
x <- c(1, 4, 6.25, NA)
x[!is.na(x) & x > 2]
```
### 1.4.6 `which()` `which.min()`  `which.max()`

* 函数`which()`可以用来找到满足条件的下标
*` which.min()`、`which.max()`求最小值的下标和最大值的下标， 不唯一时只取第一个。如

```{r}
x <- c(3, 4, 3, 5, 7, 5, 9)
x[which(x > 5)]     # 返回x向量大于5的值, 等价于 x[x>5]
x[which.min(x)]     # 返回x向量中最小值, 删除NA后的向量
x[which.max(x)]     # 返回x向量中最大值
```

### 1.4.7 元素名

* 向量可以为每个元素命名。如
```{r}
ages <- c("李明"=30, "张聪"=25, "刘颖"=28)                          # 或
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")    # 或
ages <- setNames(c(30, 25, 28), c("李明", "张聪", "刘颖"))
ages
```
* 可以用元素名或元素名向量作为向量的下标，这实际上建立了字符串到数值的映射表。如
```{r}
ages[c("李明", "刘颖")]
ages[c(1,3)]
``` 
* 用 `unname(x)` 返回去掉了元素名的x的副本，x向量值不变， 用 `names(x) <- NULL` 直接去掉x的元素名，不返回任何值。

```{r}
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")  
unname(ages)       # 直接返回
ages
```
```{r}
ages <- c(30, 25, 28) ; names(ages) <- c("李明", "张聪", "刘颖")  
names(ages) <- NULL  # 不返回x的值
ages
```

### 1.4.8 向量下标作映射

R在使用整数作为向量下标时，允许使用重复下标， 这样可以把数组x看成一个的整数到 x[1], x[2], , x[n]的一个映射表, 其中是x的长度。

* sex为10个学生的性别（男、女），希望把每个学生按照性别分别对应到蓝色和红色。
```{r}
sex <- c("男", "男", "女", "女", "男", "女", "女", "女", "女", "男")
sex_color <- c("男"="blue", "女"="red")
cols <- sex_color[sex]; print(cols)

cols <- unname(cols) ; cols          # 去掉元素名
```

### 1.4.9 集合运算

向量x看成一个集合

*  `unique(x)` 可以获得x的唯一值
*  `a %in% x` 判断a的每个元素是否属于向量x，如
*  `intersect(x,y)`求交集
*  `union(x,y)` 求并集
*  `setdiff(x,y)`求差集，即x的元素中不属于y的元素组成的集合
*  `setequal(x,y)`判断两个集合是否相等， 不受次序与重复元素的影响

```{r}
unique(c(1, 5, 2, 5))
c(5,6) %in% c(1,5,2)
intersect(c(5, 7), c(1, 5, 2, 5))
union(c(5, 7), c(1, 5, 2, 5))
setdiff(c(5, 7), c(1, 5, 2, 5))
setequal(c(1,5,2), c(2,5,1))
```

## 1.5 数据类型性质

### 1.5.1 存储模式与基本类型

* `typeof()` 函数来返回一个变量或表达式的类型
```{r}
typeof(c(1:4))
typeof(c(1,4))
typeof(factor(c('F', 'M', 'M', 'F')))
```

 R中数据的最基本的类型包括logical, integer, double, character, complex, raw, 其它数据类型都是由基本类型组合或转变得到的。

* 逻辑型（logical）
* 整数型（integer），只能用来储存正数。
    * 缺失值是NA
* 双整型（double），可正可负，可大可小，可含小数可不含，在数据科学里，它更常被称为数值型（numeric）
    * 缺失值是 `NA` 和 `NaN`也算是缺失值, `is.na()`判断是否`NA`或`NaN`； `is.nan()`判断是否`NaN`
    * `Inf`和`-Inf`不算是缺失值，·`is.infinite()`判断是否`Inf`或`-Inf`；
```{r}
is.integer(c(1, -3))    # 只能是整数，
is.integer(c(1L, -3L))  # 需要明确表明某些数值是整数， 可以在数值后面附加字母L
is.double(c(1, -3))
is.numeric(c(1, -3))    # integer和double内容都返回真值。
```
```{r}
c(-1, 0, 1)/0
is.na(c(-1, 0, 1)/0)
```
* 字符型（character）
* 复数型（complex）
* 原始型（raw), 是直接使用其二进制内容的类型
* `NULL`类型，只有唯一值是`NULL`值,表示不存在。 `NULL`长度为0， 不能有任何属性值。 
    * `is.null()`函数判断某个变量是否取NULL。

### 1.5.2 类型转换与类型升档

* 强制类型转换：`as.xxx()` 函数
* 隐藏类型转换：
    * 四则运算中数值会被统一转换为double类型， 
    * 逻辑运算中运算元素会被统一转换为logical类型。 
    * 逻辑值转换成数值时，TRUE转换成1， FALSE转换成0
```{r}
as.numeric(c(F, T))
as.character(c(1, pi))
typeof(3+4)
TRUE + 4
```
* 在用c()函数合并若干元素时， 如果元素基本类型不同， 将统一转换成最复杂的一个，复杂程度从简单到复杂依次为： `logical<integer<double<character`。 这种做法称为类型**升档**

```{r}
c(FALSE, 1L, 2.5, "3.6")     # 最复杂的是字符串型，最后都升挡为字符串型
```

* 不同类型参与要求类型相同的运算时， 也会统一转换为最复杂的类型， 也称为类型升档，

```{r}
TRUE + 10
paste("abc", 1)
```

### 1.5.3 属性
除了NULL以外， R的变量都可以看成是对象， 都可以有属性。 在R语言中， 属性是把变量看成对象后， 除了其存储内容（如元素）之外的其它附加信息， 如维数、类属等。 R对象一般都有`length`和`mode`两个属性。常用属性有`names`, `dim`，`class`等

#### 1.5.3.1 attribute 函数

`table()`函数用了输出其自变量中每个不同值的出现次数，称为频数。
```{r}
x <- table(c(1,2,1,3,2,1)); print(x)
attributes(x)
```
> dim和dimnames, 这是数组(array)具有的属性

attributes()函数修改属性， 如

```{r}
attributes(x) <- NULL; x    # 修改后x不再是数组，也不是table。
```

#### 1.5.3.2 attr(x,"属性名") 函数

读取或定义x的属性
```{r}
x <- c(1,3,5)
attr(x, "theta") <- c(0, 1)
print(x)

attr(x, "theta")   # 读取属性

```
> 可以让向量x额外地保存一个theta属性， 这样的属性常常成为“元数据”(meta data)， 比如， 用来保存数据的说明、模拟数据的真实模型参数

#### 1.5.3.3 names() 属性

* 有元素名的向量、列表、数据框等都有names属性， 许多R函数的输出本质上也是列表， 所以也有names属性。 用names(x)的格式读取或设定
* 对于没有元素名的向量x，names(x)的返回值是NULL
```{r}
x <- 1:5 ; y <- x^2 ; lmr <- lm(y ~ x)
print(names(lmr))
```

#### 1.5.3.4 dim() 属性

* `dim`属性的存在表明对象是矩阵或一维、多维数组。 如：
```{r}
x <- matrix(1:12, nrow=3, ncol=4)
attr(x, "dim") # 等同于dim(x)
```

### 1.5.4 类属性

* 函数class()可以返回变量类型的类属
```{r}
typeof(factor(c('F', 'M', 'M', 'F')))
## [1] "integer"
mode(factor(c('F', 'M', 'M', 'F')))
## [1] "numeric"
storage.mode(factor(c('F', 'M', 'M', 'F')))
## [1] "integer"
class(factor(c('F', 'M', 'M', 'F')))
## [1] "factor"
class(as.numeric(factor(c('F', 'M', 'M', 'F'))))
## [1] "numeric"
```

### 1.5.5 str()函数

用`print()`函数可以显示对象内容。 如果内容很多，显示行数可能也很多。 用`str()`函数可以显示对象的类型和主要结构及典型内容。例如

```{r}
s <- 101:200
attr(s,'author') <- '李小明'
attr(s,'date') <- '2016-09-12'
str(s)

print(s)
```

## 1.6 日期时间

### 1.6.1 日期和日期时间类型

* R日期可以保存为Date类型， 一般用整数保存，数值为从1970-1-1经过的天数。
* 特殊的POSIXct和POSIXlt
    * POSIXct把日期时间保存为从1970年1月1日零时到该日期时间的时间间隔秒数， 所以数据框中需要保存日期时用POSIXct比较合适， 需要显示时再转换成字符串形式；
    * POSIXlt把日期时间保存为一个包含年、月、日、星期、时、分、秒等成分的列表， 所以求这些成分可以从POSIXlt格式日期的列表变量中获得。

```{r}
library(lubridate)
```


### 1.6.2 从字符串生成日期数据

```{r}
lubridate::today()  # 返回当前日期: "2023-10-19"

lubridate::now()    # 返回当前日期时间: "2023-10-19 20:00:57 CST" , CST表示时区
```

* 用`lubridate::ymd()`, `lubridate::mdy()`, `lubridate::dmy()`将字符型向量转换为日期型向量
    * 在年号只有两位数字时，默认对应到1969-2068范围。
```{r}
lubridate::ymd(c("2023-10-19", "2023.10.1", "18-1-17", "20230110"))
lubridate::mdy(c("10-19-2023", "10.1.2023", "1-17-18", '01102023'))
lubridate::dmy(c("19-10-2023", "1.10.2023", "17-1-18", '10012023'))
```
* `lubridate`包的`ymd`、`mdy`、`dmy`等函数添加`hms`、`hm`、`h`等后缀， 可以用于将字符串转换成日期时间。 如
```{r}
lubridate::ymd_hms("1998-03-16 13:15:45", '20231019 20:17:59',  '20231019201759')
```

### 1.6.3 时区和时区转换

* 在`Date()`、`as.DateTime()`、`ymd()`等函数中， 可以用`tz=指定时区`， 
    * 北京时间可指定为`tz="Etc/GMT-8"`或 `tz="Asia/Shanghai"`。
```{r}
ymd_hms(c("1998-03-16 13:15:45", "2023-03-14 10:11:12"), tz="Asia/Shanghai")
```
* 为了将某个时间转换到指定的时区， 而不改变真正的时间， 用with_tz()函数
```{r}
with_tz(ymd_hms(c("1990-09-08 9:11:30", "2023-10-10 10:11:12"), tz="Etc/GMT-8"), tzone="UTC") # 改用东八区时间，原始时间减8小时
```

* 为了保持表面的时间（时钟显示的日期时间）不变， 但将**真正的时间修改到另外的时区**， 用`force_tz()`或`force_tzs()`， 其中`force_tzs()`可以将每个时间单独应用不同的时区。 如：
```{r}
force_tz(ymd_hms(c("20100908 101030", "20231019 101030"), tz="Etc/GMT-8"), tzone = "UTC")
```
```{r}
force_tzs(ymd_hms(c("1998-03-16 13:15:45", "2023-03-14 10:11:12"),
                  tz="Asia/Shanghai"), 
          tzones=c("Etc/GMT-6", "Etc/GMT-10"))
```
> 这将北京时间"1998-03-16 13:15:45"改成了东6区时间， 对应到UTC就是钟面时间减6， 所以13点变成7点， 将北京时间"2023-03-14 10:11:12"改成了东10区时间， 对应到UTC就是钟面时间减10，所以10点变成0点。 输入的日期中的时区"Asia/Shanghai"不起作用， 仅该时区的钟面时间起作用。


### 1.6.4 从数值生成日期数据

* `lubridate::make_date(year, month, day)`可以从三个数值构成日期向量。 如
```{r}
make_date(2023, 10,1)
```

* `lubridate::make_datetime(year, month, day, hour, min, sec)` 可以从最多六个数值组成日期时间， 其中时分秒缺省值都是0。 如
```{r}
c(make_datetime(2023, 10, 1, 10, 0 ,0), make_datetime(2023, 10, 1, 10, 0 ,0, tz="Etc/GMT-0"))
```

### 1.6.5 日期和日期时间之间的转换

* `lubridate::as_date()`可以将日期时间型转换为日期型，如
```{r}
as_date(ymd_hms("20231001 10:08:00"))
```

* `lubridate::as_datetime()`可以将日期型数据转换为日期时间型
```{r}
as.Date("2023-10-01") |> 
    as_datetime() |> 
    class()
```

### 1.6.6 日期显示格式

* 用`as.character()`函数把日期型数据转换为字符型
```{r}
x <- as.POSIXct(c('1998-03-16', '2015-11-22'))
as.character(x)
as.Date(c("12/6/2022", "1/1/2023"), format="%m/%d/%Y")
```

### 1.6.7 访问日期时间的组成值

* lubridate包的如下函数可以取出日期型或日期时间型数据中的组成部分：
    * `year()`取出年
    * `month()`取出月份数值
    * `mday()`取出日数值
    * `yday()`取出日期在一年中的序号，元旦为1
    * `wday()`取出日期在一个星期内的序号， 但是一个星期从星期天开始， 星期天为1,星期一为2，星期六为7。
    * `hour()`取出小时
    * `minute()`取出分钟
    * `second()`取出秒
```{r}
mday(as.POSIXct("2018-1-17 13:15:40"))
```
* lubridate的这些成分函数还允许被赋值， 结果就修改了相应元素的值，如
```{r}
x <- as.POSIXct("2018-1-17 13:15:40") ; year(x) <- 2000 ; x
```

### 1.6.8 日期舍入计算

lubridate包提供了floor_date(), round_date(), ceiling_date()等函数， 对日期可以用unit=指定一个时间单位进行舍入。 时间单位为字符串， 如seconds, 5 seconds, minutes, 2 minutes, hours, days, weeks, months, years等。

> 比如，以10 minutes为单位， 
>    * `floor_date()`将时间向前归一化到10分钟的整数倍， 
>    * `ceiling_date()`将时间向后归一化到10分钟的整数倍， 
>    * `round_date()`将时间归一化到最近的10分钟的整数倍， 时间恰好是5分钟倍数时按照类似四舍五入的原则向上取整。 例如

```{r}
x <- ymd_hms("2018-01-11 08:32:44")
floor_date(x, unit="10 minutes")
floor_date(x, "season")
```
### 1.6.9 日期计算

在lubridate的支持下日期可以相减， 可以进行加法、除法。 lubridate包提供了如下的三种与时间长短有关的数据类型：

* 时间长度(duration)，按整秒计算;
* 时间周期(period)，如日、周;
* 时间区间(interval)，包括一个开始时间和一个结束时间。

#### 1.6.9.1 时间长度

* R的POSIXct日期时间之间可以相减，如

```{r}
d1 <- ymd_hms("2023-10-24 0:0:0")
d2 <- ymd_hms("2000-01-01 12:0:5")
di <- d1 - d2; di                   # 结果是类型是difftime,  可以用as.double(di, units="secs")转化


as.double(di, units = "days")       # days / hours / mins / secs

as.duration(di)                     # 固定以秒作为基本单位



```

`
* lubridate的`dseconds()`, `dminutes()`, `dhours()`, `ddays()`, `dweeks()`, `dyears()`函数可以直接生成时间长度类型的数据，如

```{r}
dhours(1) + dseconds(5)
dhours(1)*10
d2 <- ymd_hms("2000-01-02 12:0:5")
d2 - dhours(5)      # 日期加或者减去一个时间长度， 结果严格按推移的秒数计算
d2 + ddays(10)


```

## 1.7 因子类型
### 1.7.1 因子
R中用因子代表数据中**分类变量**, 如性别、省份、职业。 有序因子代表有序量度，如打分结果，疾病严重程度等。

* 用`factor()`函数把字符型向量转换成因子，如

```{r}
x <- c("男", "女", "男", "男",  "女")
sex <- factor(x)
sex
attributes(sex)
```
> `read.csv()`函数的默认操作会把输入文件的字符型列自动转换成因子， 这对于性别、职业、地名这样的列是合适的， 但是对于姓名、日期、详细地址这样的列则不合适。 所以，在read.csv()调用中经常加选项`stringsAsFactors=FALSE`选项禁止这样的自动转换，还可以用colClasses选项逐个指定每列的类型。 
> readr包的`read_csv()`函数， 这个函数读入CSV时不自动转换因子， 生成data.frame的替代类型tibble。


* 用`as.numeric()`可以把因子转换为纯粹的整数值，如 
```{r}
as.numeric(sex)
```
* 用`as.character()`可以把因子转换成原来的字符型，如
```{r}
as.character(sex)
```
* `factor()`的一般形式
    * `levels`自行指定各水平值, 不指定时由x的不同值来求
    * `labels`指定各水平的标签, 不指定时用各水平值的对应字符串
    * 
    
```{r}
# factor(x = character(), levels, labels = levels,
 #      exclude = NA, ordered = is.ordered(x), nmax = NA)
```

### 1.7.2 cut() 函数分段
* 连续取值的变量，可以用cut()函数将其分段， 转换成因子。
    * `breaks=n` 等间距分组,分组个数是n.
```{r}
set.seed(1)
x <- sort(round(rnorm(20), 2))
f <- cut(x, breaks=4); f
levels(f) <- c("a", "b", "c", "d"); f       # 修改水平标记
```
* 各组个数平均分组， 可以利用`quantile()`函数计算分位数作为分组
    * `oredered_result=TRUE`表示生成有序因子
```{r}
cu <- quantile(x, c(0, 1/4, 1/2, 3/4, 1))
cu[1] <- cu[1] - 0.01*(cu[5] - cu[1])
f2 <- cut(x, breaks=cu, oredered_result=TRUE)
levels(f2) <- c("a", "b", "c", "d"); f2
```
### 1.7.3 table() 统计因子各水平的出现次数
* 一般的向量统计每个不同元素的出现次数

```{r}
x <- c("男", "女", "男", "男",  "女")
sex <- factor(x)
table(sex)

```
### 1.7.4 tapply() 按照因子分组然后每组计算另一变量的概括统计

```{r}
h <- c(165, 170, 168, 172, 159)
tapply(h, sex, mean)
```
> 第一自变量h与与第二自变量sex是等长的， 对应元素分别为同一人的身高和性别， tapply()函数分男女两组计算了身高平均值。


### 1.7.5 forcats包的因子函数
https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/prog-type-fact.html#summ-by-forcats



## 1.8 列表类型
### 1.8.1 列表
* 列表(list)类型来保存不同类型的数据, 一个主要目的是提供R分析结果输出包装。
* 列表的不同元素的类型可以不同, 列表不要求各列等长。

```{r}
rec <- list(name="李明", age=30,
  scores=c(85, 76, 90))
rec


typeof(rec)     # 查看类型
is.list(rec)    # 判断某个对象是否列表类型

vector("list", 5)   # 生成元素为空的长度为n的列表

```
### 1.8.2 列表元素访问
#### 1.8.2.1 查
* 方式1：**双层**中括号,返回子元素的实际类型
```{r}
rec[[3]]
rec[[3]][2]
rec[['age']]
typeof(rec[[1]])   # 返回 character
```

* 方式2：`$`访问
```{r}
typeof(rec$name)   # 返回 character
```

* 方式3：单中括号，取列表的子集，返回的结果是列表
```{r}
rec[3]
rec['age']
is.list(rec[1])
```

#### 1.8.1.2 元素名
* 列表一般都应该有元素名， 元素名可以看成是变量名， 列表中的每个元素看成一个变量。 用names()函数查看和修改元素名
```{r}
names(rec)                                       # 查看列表中所有的元素名
names(rec)[names(rec)=="scores"] <- "三科分数"   # 修改元素名
rec[["三科分数"]]
```
#### 1.8.2.3 修改列表元素内容
1. 修改已经存在元素

```{r}
rec[['三科分数']][2] <- 0
```

2. 给列表**不存在的元素**名定义元素值就添加了新元素
```{r}
rec[["身高"]] <- 175
rec

```
3. 某个**列表元素**赋值为`NULL`就删掉这个元素
```{r}
rec[["age"]] <- NULL
print(rec)
```
4. 在list()函数中允许定义元素为NULL，这样的元素是存在的
```{r}
li <- list(a=120, b="F", c=NULL); li
li['b'] <- list(NULL); li

```

### 1.8.3 列表类型转换
* 用`as.list()`把一个其它类型的对象转换成列表； 
* 用`unlist()`函数把列表转换成基本向量

```{r}
li1 <- as.list(1:3); li1
li2 <- list(x=1, y=c(2,3));unlist(li2)
```
### 1.8.4 连接列表
```{r}
li <- list()
li <- c(li, list(1:3))
li <- c(li, list(11:13))
li
```
### 1.8.5 返回列表的函数示例 - `strsplit()`
```{r}
x <- c("10, 8, 7", "5, 2, 2", "3, 7, 8", "8, 8, 9")
res <- strsplit(x, ","); res                # 返回列表
t(sapply(res, as.numeric))
```
> 列表、向量或数据帧作为输入，并以向量或矩阵的形式给出输出。

## 1.9 矩阵与数组
### 1.9.1 矩阵
矩阵用matrix函数定义，实际存储成一个向量，根据保存的行数和列数对应到矩阵的元素， 默认的存储次序为**按列**存储，用`byrow=TRUE`选项可以设置成**按行**填入。 
```{r}
A <- matrix(11:16, nrow=3, ncol=2,byrow = TRUE); print(A)
attributes(A)$dim    # 等价于 dim(A),返回A的维度
nrow(A)     # A的行数
ncol(A)     # A的列数
t(A)        # 返回A的转置
```
### 1.9.2 矩阵子集
#### 1.9.2.1 子集 
```{r}
A[1,] # 取出A的第一行，变成一个普通向量。 
A[,1] # 取出A的第一列，变成一个普通向量。 
A[c(1,3),1:2]    #取出指定行、列对应的子矩阵

```
#### 1.9.2.2 行列命名
```{r}
colnames(A) <- c('X', 'Y')        # 给矩阵每列命名， 也可以访问矩阵列名
rownames(A) <- c('a', 'b', 'c')   # 给矩阵每行命名， 也可以访问矩阵行名
A[c('a', 'c'), 'Y']
```
#### 1.9.2.3. `drop=FALSE`参数生成列向量
矩阵取子集时， 如果取出的子集仅有一行或仅有一列， 结果就不再是矩阵而是变成了R向量， R向量既不是行向量也不是列向量
```{r}
A[,1,drop=FALSE]
```
### 1.9.3 cbind()和rbind()函数

* 若x1, x2, x3是等长的向量， `cbind(x1, x2, x3)`把它们看成列向量并在一起组成一个矩阵。
```{r}
cbind(c(1,2), c(3,4), c(5,6))
cbind(A,Z=c(1,2,3))
```
* `cbind()`的自变量中也允许有标量， 这时此标量被重复使用
```{r}
cbind(1, c(1,-1,10))
```
* `rbind()`用法类似， 可以等长的向量看成行向量上下摞在一起， 可以是矩阵与长度等于矩阵列数的向量上下摞在一起， 向量长度为1也可以。

### 1.9.4 矩阵运算
#### 1.9.4.1 四则运算（+-*/）
1. 与标量,结果为每个元素进行相应运算
2. 两个同形状的矩阵进行加、减运算， 即对应元素相加、相减， 这就是线性代数中矩阵的加、减运算。
3. 两个同形状的矩阵进行乘、除运算， 即对应元素相乘、相除。

#### 1.9.4.2 矩阵乘法
用`%*%`表示矩阵乘法而不是用`*`表示， 注意矩阵乘法要求*左边的矩阵的列数*等于*右边的矩阵的行数*

```{r}
A <- matrix(11:16, nrow = 3, ncol = 2)
B <- matrix(c(1,1,-1,1), nrow = 2, ncol = 2)
A%*%B
```

#### 1.9.4.3 向量与矩阵向乘

矩阵与向量进行乘法运算时， 向量按需要解释成列向量或行向量。 当向量左乘矩阵时，看成行向量； 当向量右乘矩阵时，看成列向量
```{r}
c(1,1) %*% B    # 行向量 ： 1X2 %*% 2X2 == 1X2
B %*% c(1,1)    # 列向量 ： 2X2 %*% 2X1 == 1X2
```
#### 1.9.4.4 内积

设x, y是两个向量， 计算向量内积， 可以用sum(x*y)表示。

#### 1.9.4.5 外积
外积: `%o%`, 结果为矩阵。 `x %o% y`的第i行第j列元素等于x[i]乘以y[j]

### 1.9.5 apply()函数
1. `apply(A, 2, FUN)`把矩阵A的每一列分别输入到函数FUN中， 得到对应于每一列的结果
```{r}
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); apply(D, 2, sum)
```
2. `apply(A, 1, FUN)`把矩阵A的每一行分别输入到函数FUN中， 得到与每一行对应的结果

```{r}
D <- matrix(c(6,2,3,5,4,1), nrow=3, ncol=2); apply(D, 1,mean)
```
3. 函数FUN返回多个结果， 则`apply(A, 2, FUN)`结果为矩阵， 矩阵的每一列是输入矩阵相应列输入到FUN的结果， 结果列数等于A的列数

```{r}
apply(D, 2, range)    # 返回每列的min和max,在同一列
```

4. 函数FUN返回多个结果， 为了对每行计算FUN的结果， 结果存入一个与输入的矩阵行数相同的矩阵， 应该用t(apply(A, 1, FUN))的形式
```{r}
t(apply(D, 1, range) )
```

### 1.9.6 多维数组
矩阵是多维数组(array)的特例，也称二维数组。
定义语法：
    `数组名 <- array(数组元素, dim=c(第一下标个数, 第二下标个数, ..., 第s下标个数))`
其中数组元素的填入次序是第一下标变化最快， 第二下标次之， 最后一个下标是变化最慢的。 这种次序称为FORTRAN次序。

如:定义一个三维数组
```{r}
ara <- array(1:24, dim=c(2,3,4)); ara
```
### 1.9.7 列表类型的数组
矩阵一般用于数值计算，所以其元素一般是数值。 但是，在更复杂的编程场景中，可能需要在矩阵（或数组）元素中保存复杂结构， 比如， 每个元素是一个长度可变的向量。这时，可以将矩阵元素设为列表类型，但访问其元素需要使用部分列表访问语法格式。
```{r}
L <- matrix(list(), nrow=2, ncol=2); L          # s1. 生成未初始化的列表类型的矩阵
L[1,1] <- list(1:2) ; L[1,2] <- list(3:5) 
L[2,1] <- list(6:10) ; L[2,2] <- list(11:15)    # s2. 给每个矩阵元素赋值为仅有一个元素的列表：
L[2,2]                                     # s3. 元素为仅一个元素的列表
```

```{r}
f <- function() {
  x <- seq(0, 2*pi, length=50)
  y1 <- sin(x)
  y2 <- cos(x)
  plot(x, y1, type="l", lwd=2, col="red",
       xlab="x", ylab="")
  lines(x, y2, lwd=2, col="blue")
  abline(h=0, col="gray")
}
f()
```

